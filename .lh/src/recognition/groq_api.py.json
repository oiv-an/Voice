{
    "sourceFile": "src/recognition/groq_api.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1764289619668,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764301618046,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,14 @@\n from __future__ import annotations\r\n \r\n import io\r\n from dataclasses import dataclass\r\n-from typing import Any\r\n+from typing import Any, Tuple\r\n \r\n import numpy as np\r\n import requests  # type: ignore[import]\r\n import soundfile as sf  # type: ignore[import]\r\n+from loguru import logger  # type: ignore[import]\r\n \r\n from config.settings import GroqRecognitionConfig\r\n from audio.recorder import AudioData\r\n \r\n@@ -20,8 +21,11 @@\n     \"\"\"\r\n     Minimal Groq Whisper recognizer for MVP.\r\n \r\n     Converts AudioData to in-memory WAV and sends it to Groq Whisper endpoint.\r\n+\r\n+    Для удобства обработки ошибок метод transcribe возвращает только текст\r\n+    и выбрасывает осмысленные исключения с человекочитаемыми сообщениями.\r\n     \"\"\"\r\n \r\n     config: GroqRecognitionConfig\r\n \r\n@@ -40,14 +44,51 @@\n             \"model\": self.config.model,\r\n             \"language\": self.config.language,\r\n         }\r\n \r\n-        resp = requests.post(GROQ_TRANSCRIBE_URL, headers=headers, files=files, data=data, timeout=60)\r\n-        resp.raise_for_status()\r\n-        payload: dict[str, Any] = resp.json()\r\n-        # Groq is OpenAI-compatible: text is in 'text'\r\n-        return payload.get(\"text\", \"\")\r\n+        try:\r\n+            resp = requests.post(\r\n+                GROQ_TRANSCRIBE_URL,\r\n+                headers=headers,\r\n+                files=files,\r\n+                data=data,\r\n+                timeout=60,\r\n+            )\r\n+        except requests.Timeout as exc:  # type: ignore[attr-defined]\r\n+            logger.exception(\"Groq request timeout: {}\", exc)\r\n+            raise RuntimeError(\"Groq: превышено время ожидания ответа.\") from exc\r\n+        except requests.RequestException as exc:  # type: ignore[attr-defined]\r\n+            logger.exception(\"Groq network error: {}\", exc)\r\n+            raise RuntimeError(\"Groq: сетевая ошибка при обращении к API.\") from exc\r\n \r\n+        # HTTP-ошибки обрабатываем с разными сообщениями\r\n+        if resp.status_code == 401:\r\n+            logger.error(\"Groq returned 401 Unauthorized\")\r\n+            raise RuntimeError(\"Groq: неверный или отсутствующий API‑ключ (401).\")\r\n+        if resp.status_code == 429:\r\n+            logger.error(\"Groq returned 429 Too Many Requests\")\r\n+            raise RuntimeError(\"Groq: превышен лимит запросов (429). Попробуйте позже.\")\r\n+        if not resp.ok:\r\n+            logger.error(\r\n+                \"Groq returned HTTP {}: {}\",\r\n+                resp.status_code,\r\n+                resp.text[:500],\r\n+            )\r\n+            raise RuntimeError(f\"Groq: ошибка сервера ({resp.status_code}).\")\r\n+\r\n+        try:\r\n+            payload: dict[str, Any] = resp.json()\r\n+        except ValueError as exc:\r\n+            logger.exception(\"Groq JSON parse error: {}\", exc)\r\n+            raise RuntimeError(\"Groq: не удалось разобрать ответ сервера.\") from exc\r\n+\r\n+        text = payload.get(\"text\", \"\")\r\n+        if not isinstance(text, str):\r\n+            logger.error(\"Groq response does not contain 'text' field: {}\", payload)\r\n+            raise RuntimeError(\"Groq: в ответе нет поля 'text'.\")\r\n+\r\n+        return text\r\n+\r\n     @staticmethod\r\n     def _audio_to_wav_bytes(audio: AudioData) -> bytes:\r\n         \"\"\"\r\n         Convert AudioData (float32 numpy) to WAV bytes (16kHz mono).\r\n"
                },
                {
                    "date": 1764463508054,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,8 +29,16 @@\n \r\n     config: GroqRecognitionConfig\r\n \r\n     def transcribe(self, audio: AudioData) -> str:\r\n+        \"\"\"\r\n+        Две попытки запроса к Groq:\r\n+        - первая сразу,\r\n+        - вторая через 1 секунду, если первая упала по timeout / сетевой ошибке.\r\n+        Если обе попытки неудачны — выбрасываем RuntimeError.\r\n+        \"\"\"\r\n+        import time\r\n+\r\n         wav_bytes = self._audio_to_wav_bytes(audio)\r\n \r\n         headers = {\r\n             \"Authorization\": f\"Bearer {self.config.api_key}\",\r\n@@ -44,23 +52,39 @@\n             \"model\": self.config.model,\r\n             \"language\": self.config.language,\r\n         }\r\n \r\n-        try:\r\n-            resp = requests.post(\r\n-                GROQ_TRANSCRIBE_URL,\r\n-                headers=headers,\r\n-                files=files,\r\n-                data=data,\r\n-                timeout=60,\r\n-            )\r\n-        except requests.Timeout as exc:  # type: ignore[attr-defined]\r\n-            logger.exception(\"Groq request timeout: {}\", exc)\r\n-            raise RuntimeError(\"Groq: превышено время ожидания ответа.\") from exc\r\n-        except requests.RequestException as exc:  # type: ignore[attr-defined]\r\n-            logger.exception(\"Groq network error: {}\", exc)\r\n-            raise RuntimeError(\"Groq: сетевая ошибка при обращении к API.\") from exc\r\n+        last_exc: Exception | None = None\r\n \r\n+        for attempt in (1, 2):\r\n+            try:\r\n+                logger.info(\"Groq request attempt {} to {}\", attempt, GROQ_TRANSCRIBE_URL)\r\n+                resp = requests.post(\r\n+                    GROQ_TRANSCRIBE_URL,\r\n+                    headers=headers,\r\n+                    files=files,\r\n+                    data=data,\r\n+                    timeout=60,\r\n+                )\r\n+                # Если дошли до сюда — HTTP-запрос выполнен, выходим из цикла\r\n+                break\r\n+            except requests.Timeout as exc:  # type: ignore[attr-defined]\r\n+                logger.exception(\"Groq request timeout (attempt {}): {}\", attempt, exc)\r\n+                last_exc = exc\r\n+            except requests.RequestException as exc:  # type: ignore[attr-defined]\r\n+                logger.exception(\"Groq network error (attempt {}): {}\", attempt, exc)\r\n+                last_exc = exc\r\n+\r\n+            if attempt == 1:\r\n+                # Пауза 1 секунда перед второй попыткой\r\n+                time.sleep(1.0)\r\n+\r\n+        # Если обе попытки не удались — поднимаем осмысленную ошибку\r\n+        if last_exc is not None and \"resp\" not in locals():\r\n+            if isinstance(last_exc, requests.Timeout):  # type: ignore[attr-defined]\r\n+                raise RuntimeError(\"Groq: превышено время ожидания ответа.\") from last_exc\r\n+            raise RuntimeError(\"Groq: сетевая ошибка при обращении к API.\") from last_exc\r\n+\r\n         # HTTP-ошибки обрабатываем с разными сообщениями\r\n         if resp.status_code == 401:\r\n             logger.error(\"Groq returned 401 Unauthorized\")\r\n             raise RuntimeError(\"Groq: неверный или отсутствующий API‑ключ (401).\")\r\n"
                },
                {
                    "date": 1764591261159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,10 +8,10 @@\n import requests  # type: ignore[import]\r\n import soundfile as sf  # type: ignore[import]\r\n from loguru import logger  # type: ignore[import]\r\n \r\n-from config.settings import GroqRecognitionConfig\r\n-from audio.recorder import AudioData\r\n+from src.config.settings import GroqRecognitionConfig\r\n+from src.audio.recorder import AudioData\r\n \r\n \r\n GROQ_TRANSCRIBE_URL = \"https://api.groq.com/openai/v1/audio/transcriptions\"\r\n \r\n"
                }
            ],
            "date": 1764289619668,
            "name": "Commit-0",
            "content": "from __future__ import annotations\r\n\r\nimport io\r\nfrom dataclasses import dataclass\r\nfrom typing import Any\r\n\r\nimport numpy as np\r\nimport requests  # type: ignore[import]\r\nimport soundfile as sf  # type: ignore[import]\r\n\r\nfrom config.settings import GroqRecognitionConfig\r\nfrom audio.recorder import AudioData\r\n\r\n\r\nGROQ_TRANSCRIBE_URL = \"https://api.groq.com/openai/v1/audio/transcriptions\"\r\n\r\n\r\n@dataclass\r\nclass GroqWhisperRecognizer:\r\n    \"\"\"\r\n    Minimal Groq Whisper recognizer for MVP.\r\n\r\n    Converts AudioData to in-memory WAV and sends it to Groq Whisper endpoint.\r\n    \"\"\"\r\n\r\n    config: GroqRecognitionConfig\r\n\r\n    def transcribe(self, audio: AudioData) -> str:\r\n        wav_bytes = self._audio_to_wav_bytes(audio)\r\n\r\n        headers = {\r\n            \"Authorization\": f\"Bearer {self.config.api_key}\",\r\n        }\r\n\r\n        files = {\r\n            \"file\": (\"audio.wav\", wav_bytes, \"audio/wav\"),\r\n        }\r\n\r\n        data = {\r\n            \"model\": self.config.model,\r\n            \"language\": self.config.language,\r\n        }\r\n\r\n        resp = requests.post(GROQ_TRANSCRIBE_URL, headers=headers, files=files, data=data, timeout=60)\r\n        resp.raise_for_status()\r\n        payload: dict[str, Any] = resp.json()\r\n        # Groq is OpenAI-compatible: text is in 'text'\r\n        return payload.get(\"text\", \"\")\r\n\r\n    @staticmethod\r\n    def _audio_to_wav_bytes(audio: AudioData) -> bytes:\r\n        \"\"\"\r\n        Convert AudioData (float32 numpy) to WAV bytes (16kHz mono).\r\n        \"\"\"\r\n        buf = io.BytesIO()\r\n        sf.write(buf, audio.samples, audio.sample_rate, format=\"WAV\", subtype=\"PCM_16\")\r\n        buf.seek(0)\r\n        return buf.read()"
        }
    ]
}