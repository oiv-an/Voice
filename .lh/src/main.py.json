{
    "sourceFile": "src/main.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 16,
            "patches": [
                {
                    "date": 1764291847746,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764294103165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,10 +115,24 @@\n         try:\r\n             self.window.set_state(\"processing\")\r\n             text = self.recognizer.transcribe(audio_data)\r\n             text = self.postprocessor.process(text)\r\n+\r\n+            # показать распознанный текст в окне\r\n+            try:\r\n+                # result_label добавлен во FloatingWindow\r\n+                self.window.result_label.setText(text)\r\n+            except Exception:\r\n+                # если по какой-то причине нет result_label — просто игнорируем\r\n+                pass\r\n+\r\n+            # положить текст в буфер обмена\r\n             self.clipboard.copy(text)\r\n+\r\n+            # авто-вставка сейчас отключена (paste() — заглушка),\r\n+            # пользователь вставляет текст вручную через Ctrl+V\r\n             self.clipboard.paste()\r\n+\r\n             self.window.set_state(\"ready\")\r\n         except Exception as exc:  # noqa: BLE001\r\n             from loguru import logger\r\n \r\n"
                },
                {
                    "date": 1764295812842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,11 +76,33 @@\n         else:\r\n             self.show_window()\r\n \r\n     def open_settings_dialog(self) -> None:\r\n-        # Placeholder: real implementation will open SettingsDialog\r\n-        self.window.show_message(\"Settings dialog is not implemented yet (MVP skeleton).\")\r\n+        \"\"\"\r\n+        Открыть диалог настроек:\r\n+        - выбор backend'а (Groq / OpenAI)\r\n+        - ввод API-ключей и base URL\r\n+        - обновление настроек и пересоздание recognizer'а\r\n+        \"\"\"\r\n+        from ui.settings_dialog import SettingsDialog\r\n \r\n+        dlg = SettingsDialog(self.settings, parent=self.window)\r\n+        if dlg.exec() != dlg.DialogCode.Accepted:\r\n+            return\r\n+\r\n+        new_settings = dlg.get_result()\r\n+        if new_settings is None:\r\n+            return\r\n+\r\n+        # обновляем настройки в приложении\r\n+        self.settings = new_settings\r\n+\r\n+        # пересоздаём recognizer с новыми параметрами\r\n+        self.recognizer = create_recognizer(self.settings.recognition)\r\n+\r\n+        # сообщаем пользователю\r\n+        self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n+\r\n     # ----------------------------------------------------------------- Hotkeys\r\n \r\n     def start_recording(self) -> None:\r\n         if self._is_recording:\r\n"
                },
                {
                    "date": 1764295922499,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,13 +70,19 @@\n         self.window.raise_()\r\n         self.window.activateWindow()\r\n \r\n     def toggle_window_visibility(self) -> None:\r\n-        if self.window.isVisible():\r\n-            self.window.hide()\r\n-        else:\r\n-            self.show_window()\r\n+        \"\"\"\r\n+        Горячая клавиша \"Показать/скрыть окно\".\r\n \r\n+        Для твоего сценария окно должно быть ВСЕГДА видно, поэтому\r\n+        мы больше не будем его прятать, а только:\r\n+        - если оно свернуто в компактный режим — разворачивать,\r\n+        - если оно где-то \"потерялось\" — показывать и поднимать наверх.\r\n+        \"\"\"\r\n+        # просто гарантируем, что окно показано и на переднем плане\r\n+        self.show_window()\r\n+\r\n     def open_settings_dialog(self) -> None:\r\n         \"\"\"\r\n         Открыть диалог настроек:\r\n         - выбор backend'а (Groq / OpenAI)\r\n"
                },
                {
                    "date": 1764300224731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,31 +83,41 @@\n         self.show_window()\r\n \r\n     def open_settings_dialog(self) -> None:\r\n         \"\"\"\r\n-        Открыть диалог настроек:\r\n-        - выбор backend'а (Groq / OpenAI)\r\n-        - ввод API-ключей и base URL\r\n-        - обновление настроек и пересоздание recognizer'а\r\n+        Открыть панель настроек внутри основного окна.\r\n+\r\n+        ВАЖНО: все значения берём/кладём только в config.yaml через AppSettings.\r\n         \"\"\"\r\n-        from ui.settings_dialog import SettingsDialog\r\n+        # показать окно\r\n+        self.show_window()\r\n \r\n-        dlg = SettingsDialog(self.settings, parent=self.window)\r\n-        if dlg.exec() != dlg.DialogCode.Accepted:\r\n-            return\r\n+        # заполнить UI текущими значениями из self.settings\r\n+        rec = self.settings.recognition\r\n+        post = self.settings.postprocess\r\n \r\n-        new_settings = dlg.get_result()\r\n-        if new_settings is None:\r\n-            return\r\n+        # backend\r\n+        backend_value = (rec.backend or \"groq\").lower()\r\n+        idx = self.window.settings_backend_combo.findData(backend_value)\r\n+        if idx >= 0:\r\n+            self.window.settings_backend_combo.setCurrentIndex(idx)\r\n \r\n-        # обновляем настройки в приложении\r\n-        self.settings = new_settings\r\n+        # API keys / base URL\r\n+        self.window.settings_groq_key.setText(rec.groq.api_key or \"\")\r\n+        self.window.settings_openai_key.setText(rec.openai.api_key or \"\")\r\n+        self.window.settings_openai_url.setText(rec.openai.base_url or \"\")\r\n \r\n-        # пересоздаём recognizer с новыми параметрами\r\n-        self.recognizer = create_recognizer(self.settings.recognition)\r\n+        # postprocess\r\n+        self.window.postprocess_enabled_checkbox.setChecked(post.enabled)\r\n+        self.window.postprocess_groq_model.setText(\r\n+            (post.groq.model or \"mixtral-8x7b-32768\")\r\n+        )\r\n+        self.window.postprocess_openai_model.setText(\r\n+            (post.openai.model or \"gpt-4\")\r\n+        )\r\n \r\n-        # сообщаем пользователю\r\n-        self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n+        # переключаем окно в режим настроек\r\n+        self.window._enter_settings_mode()\r\n \r\n     # ----------------------------------------------------------------- Hotkeys\r\n \r\n     def start_recording(self) -> None:\r\n"
                },
                {
                    "date": 1764300336323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,8 +56,9 @@\n         )\r\n \r\n         # Wire UI signals\r\n         self.window.settings_requested.connect(self.open_settings_dialog)\r\n+        self.window.settings_save_requested.connect(self._on_settings_save_requested)\r\n         self.window.exit_requested.connect(self.quit)\r\n         self.tray.show_window_requested.connect(self.show_window)\r\n         self.tray.settings_requested.connect(self.open_settings_dialog)\r\n         self.tray.toggle_debug_requested.connect(self.toggle_debug_mode)\r\n"
                },
                {
                    "date": 1764300531469,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -184,8 +184,50 @@\n     def toggle_debug_mode(self) -> None:\r\n         # Placeholder: will reconfigure logging level later\r\n         self.window.show_message(\"Toggle debug (not fully implemented yet).\")\r\n \r\n+    # ----------------------------------------------------------- Settings save\r\n+\r\n+    def _on_settings_save_requested(self) -> None:\r\n+        \"\"\"\r\n+        Пользователь нажал «Сохранить» в панели настроек.\r\n+        Читаем значения из UI, обновляем self.settings, сохраняем в config.yaml\r\n+        и пересоздаём recognizer/postprocessor.\r\n+        \"\"\"\r\n+        from config.settings import AppSettings  # локальный импорт, чтобы избежать циклов\r\n+\r\n+        rec = self.settings.recognition\r\n+        post = self.settings.postprocess\r\n+\r\n+        # 1) backend\r\n+        backend_data = self.window.settings_backend_combo.currentData()\r\n+        if backend_data in (\"groq\", \"openai\", \"local\"):\r\n+            rec.backend = backend_data\r\n+\r\n+        # 2) API keys / base URL\r\n+        rec.groq.api_key = self.window.settings_groq_key.text().strip()\r\n+        rec.openai.api_key = self.window.settings_openai_key.text().strip()\r\n+        base_url = self.window.settings_openai_url.text().strip()\r\n+        if base_url:\r\n+            rec.openai.base_url = base_url\r\n+\r\n+        # 3) postprocess\r\n+        post.enabled = self.window.postprocess_enabled_checkbox.isChecked()\r\n+        groq_model = self.window.postprocess_groq_model.text().strip()\r\n+        openai_model = self.window.postprocess_openai_model.text().strip()\r\n+        post.groq.model = groq_model or \"mixtral-8x7b-32768\"\r\n+        post.openai.model = openai_model or \"gpt-4\"\r\n+\r\n+        # 4) сохранить всё в config.yaml\r\n+        AppSettings.save_default(self.settings)\r\n+\r\n+        # 5) пересоздать recognizer и postprocessor\r\n+        self.recognizer = create_recognizer(self.settings.recognition)\r\n+        self.postprocessor = TextPostprocessor(self.settings.postprocess)\r\n+\r\n+        # 6) показать уведомление\r\n+        self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n+\r\n     # -------------------------------------------------------------- Lifecycle\r\n \r\n     def quit(self) -> None:\r\n         self.hotkeys.stop()\r\n"
                },
                {
                    "date": 1764300667772,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,8 +38,21 @@\n         self.audio_recorder = AudioRecorder(self.settings.audio)\r\n         self.recognizer = create_recognizer(self.settings.recognition)\r\n         self.postprocessor = TextPostprocessor(self.settings.postprocess)\r\n \r\n+        # Первое сообщение: если нет ключа для текущего backend'а — подсказка пользователю\r\n+        backend = (self.settings.recognition.backend or \"groq\").lower()\r\n+        missing_key = False\r\n+        if backend == \"groq\" and not (self.settings.recognition.groq.api_key or \"\").strip():\r\n+            missing_key = True\r\n+        elif backend == \"openai\" and not (self.settings.recognition.openai.api_key or \"\").strip():\r\n+            missing_key = True\r\n+\r\n+        if missing_key:\r\n+            self.window.result_label.setText(\r\n+                \"Добавьте API‑ключ в настройках (⚙️) перед использованием распознавания.\"\r\n+            )\r\n+\r\n         # State\r\n         self._is_recording: bool = False\r\n \r\n         # Hotkeys\r\n"
                },
                {
                    "date": 1764301634152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,8 +163,10 @@\n     # ----------------------------------------------------------- Processing\r\n \r\n     def _process_audio(self, audio_data) -> None:\r\n         \"\"\"Synchronous processing for MVP; later can be moved to worker thread.\"\"\"\r\n+        from loguru import logger\r\n+\r\n         try:\r\n             self.window.set_state(\"processing\")\r\n             text = self.recognizer.transcribe(audio_data)\r\n             text = self.postprocessor.process(text)\r\n@@ -174,24 +176,27 @@\n                 # result_label добавлен во FloatingWindow\r\n                 self.window.result_label.setText(text)\r\n             except Exception:\r\n                 # если по какой-то причине нет result_label — просто игнорируем\r\n-                pass\r\n+                logger.debug(\"result_label is not available on window\")\r\n \r\n             # положить текст в буфер обмена\r\n             self.clipboard.copy(text)\r\n \r\n-            # авто-вставка сейчас отключена (paste() — заглушка),\r\n-            # пользователь вставляет текст вручную через Ctrl+V\r\n+            # авто-вставка текста через Ctrl+V (с ретраями внутри ClipboardManager)\r\n             self.clipboard.paste()\r\n \r\n             self.window.set_state(\"ready\")\r\n+        except RuntimeError as exc:\r\n+            # Осмысленные ошибки от распознавания (например, Groq API)\r\n+            logger.error(\"Processing error: {}\", exc)\r\n+            self.window.set_state(\"error\")\r\n+            # Показываем пользователю человекочитаемое сообщение\r\n+            self.window.show_message(str(exc))\r\n         except Exception as exc:  # noqa: BLE001\r\n-            from loguru import logger\r\n-\r\n-            logger.exception(\"Error during processing: {}\", exc)\r\n+            logger.exception(\"Unexpected error during processing: {}\", exc)\r\n             self.window.set_state(\"error\")\r\n-            self.window.show_message(\"Error during recognition. See logs.\")\r\n+            self.window.show_message(\"Неизвестная ошибка распознавания. См. логи.\")\r\n \r\n     # -------------------------------------------------------------- Debug\r\n \r\n     def toggle_debug_mode(self) -> None:\r\n"
                },
                {
                    "date": 1764301744720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,15 +121,17 @@\n         self.window.settings_openai_url.setText(rec.openai.base_url or \"\")\r\n \r\n         # postprocess\r\n         self.window.postprocess_enabled_checkbox.setChecked(post.enabled)\r\n-        self.window.postprocess_groq_model.setText(\r\n-            (post.groq.model or \"mixtral-8x7b-32768\")\r\n-        )\r\n-        self.window.postprocess_openai_model.setText(\r\n-            (post.openai.model or \"gpt-4\")\r\n-        )\r\n \r\n+        # Если в конфиге пустые строки, подставляем дефолты,\r\n+        # чтобы поля в UI были уже заполнены при первом открытии.\r\n+        groq_model = (post.groq.model or \"\").strip() or \"mixtral-8x7b-32768\"\r\n+        openai_model = (post.openai.model or \"\").strip() or \"gpt-4\"\r\n+\r\n+        self.window.postprocess_groq_model.setText(groq_model)\r\n+        self.window.postprocess_openai_model.setText(openai_model)\r\n+\r\n         # переключаем окно в режим настроек\r\n         self.window._enter_settings_mode()\r\n \r\n     # ----------------------------------------------------------------- Hotkeys\r\n"
                },
                {
                    "date": 1764302203231,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,10 +124,13 @@\n         self.window.postprocess_enabled_checkbox.setChecked(post.enabled)\r\n \r\n         # Если в конфиге пустые строки, подставляем дефолты,\r\n         # чтобы поля в UI были уже заполнены при первом открытии.\r\n-        groq_model = (post.groq.model or \"\").strip() or \"mixtral-8x7b-32768\"\r\n-        openai_model = (post.openai.model or \"\").strip() or \"gpt-4\"\r\n+        # По твоему запросу:\r\n+        #   - Groq postprocess model:   llama-3.1-70b-versatile\r\n+        #   - OpenAI postprocess model: gpt-4.1\r\n+        groq_model = (post.groq.model or \"\").strip() or \"llama-3.1-70b-versatile\"\r\n+        openai_model = (post.openai.model or \"\").strip() or \"gpt-4.1\"\r\n \r\n         self.window.postprocess_groq_model.setText(groq_model)\r\n         self.window.postprocess_openai_model.setText(openai_model)\r\n \r\n"
                },
                {
                    "date": 1764302316559,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,12 +125,12 @@\n \r\n         # Если в конфиге пустые строки, подставляем дефолты,\r\n         # чтобы поля в UI были уже заполнены при первом открытии.\r\n         # По твоему запросу:\r\n-        #   - Groq postprocess model:   llama-3.1-70b-versatile\r\n-        #   - OpenAI postprocess model: gpt-4.1\r\n-        groq_model = (post.groq.model or \"\").strip() or \"llama-3.1-70b-versatile\"\r\n-        openai_model = (post.openai.model or \"\").strip() or \"gpt-4.1\"\r\n+        #   - Groq postprocess model:   mixtral-8x7b-32768\r\n+        #   - OpenAI postprocess model: gpt-5.1\r\n+        groq_model = (post.groq.model or \"\").strip() or \"mixtral-8x7b-32768\"\r\n+        openai_model = (post.openai.model or \"\").strip() or \"gpt-5.1\"\r\n \r\n         self.window.postprocess_groq_model.setText(groq_model)\r\n         self.window.postprocess_openai_model.setText(openai_model)\r\n \r\n"
                },
                {
                    "date": 1764303019785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -172,21 +172,44 @@\n         from loguru import logger\r\n \r\n         try:\r\n             self.window.set_state(\"processing\")\r\n-            text = self.recognizer.transcribe(audio_data)\r\n-            text = self.postprocessor.process(text)\r\n+            # 1) сырой текст от Whisper\r\n+            raw_text = self.recognizer.transcribe(audio_data)\r\n \r\n-            # показать распознанный текст в окне\r\n+            # 2) regex-очистка (базовый препроцессинг всегда)\r\n+            from recognition.postprocessor import TextPostprocessor as TP  # локальный импорт для статик-метода\r\n+            regex_text = TP._simple_cleanup(raw_text or \"\")\r\n+\r\n+            # 3) LLM-постпроцессинг (если включён в конфиге)\r\n+            processed_text = regex_text\r\n             try:\r\n-                # result_label добавлен во FloatingWindow\r\n-                self.window.result_label.setText(text)\r\n+                processed_text = self.postprocessor.process(raw_text or \"\")\r\n+            except RuntimeError as exc:\r\n+                # осмысленные ошибки LLM\r\n+                logger.error(\"LLM postprocess error: {}\", exc)\r\n+                self.window.show_message(str(exc))\r\n+            except Exception as exc:  # noqa: BLE001\r\n+                logger.exception(\"Unexpected LLM postprocess error: {}\", exc)\r\n+                self.window.show_message(\"Ошибка LLM-постпроцессинга. См. логи.\")\r\n+\r\n+            # 4) показать оба варианта в окне\r\n+            try:\r\n+                # верхний блок — сырой текст от Whisper\r\n+                if hasattr(self.window, \"set_raw_text\"):\r\n+                    self.window.set_raw_text(raw_text or \"\")\r\n+                else:\r\n+                    # fallback в старый result_label\r\n+                    self.window.result_label.setText(processed_text)\r\n+\r\n+                # нижний блок — обработанный текст (regex/LLM)\r\n+                if hasattr(self.window, \"set_processed_text\"):\r\n+                    self.window.set_processed_text(processed_text)\r\n             except Exception:\r\n-                # если по какой-то причине нет result_label — просто игнорируем\r\n-                logger.debug(\"result_label is not available on window\")\r\n+                logger.debug(\"window text update failed\", exc_info=True)\r\n \r\n-            # положить текст в буфер обмена\r\n-            self.clipboard.copy(text)\r\n+            # 5) положить ОБРАБОТАННЫЙ текст в буфер обмена\r\n+            self.clipboard.copy(processed_text)\r\n \r\n             # авто-вставка текста через Ctrl+V (с ретраями внутри ClipboardManager)\r\n             self.clipboard.paste()\r\n \r\n"
                },
                {
                    "date": 1764305709575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -249,28 +249,46 @@\n         if backend_data in (\"groq\", \"openai\", \"local\"):\r\n             rec.backend = backend_data\r\n \r\n         # 2) API keys / base URL\r\n-        rec.groq.api_key = self.window.settings_groq_key.text().strip()\r\n-        rec.openai.api_key = self.window.settings_openai_key.text().strip()\r\n+        rec.groq.api_key = self.window.settings_groq_key.text().strip() or rec.groq.api_key\r\n+        rec.openai.api_key = self.window.settings_openai_key.text().strip() or rec.openai.api_key\r\n         base_url = self.window.settings_openai_url.text().strip()\r\n         if base_url:\r\n             rec.openai.base_url = base_url\r\n \r\n         # 3) postprocess\r\n         post.enabled = self.window.postprocess_enabled_checkbox.isChecked()\r\n-        groq_model = self.window.postprocess_groq_model.text().strip()\r\n-        openai_model = self.window.postprocess_openai_model.text().strip()\r\n-        post.groq.model = groq_model or \"mixtral-8x7b-32768\"\r\n-        post.openai.model = openai_model or \"gpt-4\"\r\n \r\n+        # модели LLM: пишем в recognition.*.model_process и синхронизируем postprocess.*.model\r\n+        groq_model_proc = self.window.postprocess_groq_model.text().strip()\r\n+        if groq_model_proc:\r\n+            rec.groq.model_process = groq_model_proc\r\n+            post.groq.model = groq_model_proc\r\n+\r\n+        openai_model_proc = self.window.postprocess_openai_model.text().strip()\r\n+        if openai_model_proc:\r\n+            rec.openai.model_process = openai_model_proc\r\n+            post.openai.model = openai_model_proc\r\n+\r\n         # 4) сохранить всё в config.yaml\r\n         AppSettings.save_default(self.settings)\r\n \r\n         # 5) пересоздать recognizer и postprocessor\r\n         self.recognizer = create_recognizer(self.settings.recognition)\r\n-        self.postprocessor = TextPostprocessor(self.settings.postprocess)\r\n \r\n+        post_cfg = self.settings.postprocess\r\n+        if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n+            post_cfg.groq.api_key = rec.groq.api_key\r\n+            if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n+                setattr(post_cfg.groq, \"model_process\", rec.groq.model_process)\r\n+        if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n+            post_cfg.openai.api_key = rec.openai.api_key\r\n+            if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n+                setattr(post_cfg.openai, \"model_process\", rec.openai.model_process)\r\n+\r\n+        self.postprocessor = TextPostprocessor(post_cfg)\r\n+\r\n         # 6) показать уведомление\r\n         self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n \r\n     # -------------------------------------------------------------- Lifecycle\r\n"
                },
                {
                    "date": 1764305899180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,10 +36,29 @@\n         self.tray = SystemTrayIcon(self.window, self.settings.app)\r\n         self.clipboard = ClipboardManager()\r\n         self.audio_recorder = AudioRecorder(self.settings.audio)\r\n         self.recognizer = create_recognizer(self.settings.recognition)\r\n-        self.postprocessor = TextPostprocessor(self.settings.postprocess)\r\n \r\n+        # Постпроцессинг текста.\r\n+        # ВАЖНО: сразу прокидываем в postprocess.* тот же ключ и model_process,\r\n+        # что и в recognition.*, чтобы LLM работал уже при первом запуске.\r\n+        post_cfg = self.settings.postprocess\r\n+        rec_cfg = self.settings.recognition\r\n+\r\n+        if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n+            # один ключ Groq: берём из recognition.groq.api_key\r\n+            setattr(post_cfg.groq, \"api_key\", rec_cfg.groq.api_key)\r\n+            # модель LLM: из recognition.groq.model_process\r\n+            if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n+                setattr(post_cfg.groq, \"model_process\", rec_cfg.groq.model_process)\r\n+\r\n+        if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n+            setattr(post_cfg.openai, \"api_key\", rec_cfg.openai.api_key)\r\n+            if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n+                setattr(post_cfg.openai, \"model_process\", rec_cfg.openai.model_process)\r\n+\r\n+        self.postprocessor = TextPostprocessor(post_cfg)\r\n+\r\n         # Первое сообщение: если нет ключа для текущего backend'а — подсказка пользователю\r\n         backend = (self.settings.recognition.backend or \"groq\").lower()\r\n         missing_key = False\r\n         if backend == \"groq\" and not (self.settings.recognition.groq.api_key or \"\").strip():\r\n@@ -277,13 +296,13 @@\n         self.recognizer = create_recognizer(self.settings.recognition)\r\n \r\n         post_cfg = self.settings.postprocess\r\n         if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n-            post_cfg.groq.api_key = rec.groq.api_key\r\n+            setattr(post_cfg.groq, \"api_key\", rec.groq.api_key)\r\n             if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n                 setattr(post_cfg.groq, \"model_process\", rec.groq.model_process)\r\n         if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n-            post_cfg.openai.api_key = rec.openai.api_key\r\n+            setattr(post_cfg.openai, \"api_key\", rec.openai.api_key)\r\n             if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n                 setattr(post_cfg.openai, \"model_process\", rec.openai.model_process)\r\n \r\n         self.postprocessor = TextPostprocessor(post_cfg)\r\n"
                },
                {
                    "date": 1764422294029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -184,22 +184,24 @@\n         self.audio_recorder.cancel()\r\n         self.window.set_state(\"idle\")\r\n \r\n     # ----------------------------------------------------------- Processing\r\n-\r\n+    \r\n     def _process_audio(self, audio_data) -> None:\r\n         \"\"\"Synchronous processing for MVP; later can be moved to worker thread.\"\"\"\r\n         from loguru import logger\r\n-\r\n+        from pathlib import Path\r\n+        from datetime import datetime\r\n+    \r\n         try:\r\n             self.window.set_state(\"processing\")\r\n             # 1) сырой текст от Whisper\r\n             raw_text = self.recognizer.transcribe(audio_data)\r\n-\r\n+    \r\n             # 2) regex-очистка (базовый препроцессинг всегда)\r\n             from recognition.postprocessor import TextPostprocessor as TP  # локальный импорт для статик-метода\r\n             regex_text = TP._simple_cleanup(raw_text or \"\")\r\n-\r\n+    \r\n             # 3) LLM-постпроцессинг (если включён в конфиге)\r\n             processed_text = regex_text\r\n             try:\r\n                 processed_text = self.postprocessor.process(raw_text or \"\")\r\n@@ -209,30 +211,56 @@\n                 self.window.show_message(str(exc))\r\n             except Exception as exc:  # noqa: BLE001\r\n                 logger.exception(\"Unexpected LLM postprocess error: {}\", exc)\r\n                 self.window.show_message(\"Ошибка LLM-постпроцессинга. См. логи.\")\r\n-\r\n+    \r\n             # 4) показать оба варианта в окне\r\n             try:\r\n                 # верхний блок — сырой текст от Whisper\r\n                 if hasattr(self.window, \"set_raw_text\"):\r\n                     self.window.set_raw_text(raw_text or \"\")\r\n                 else:\r\n                     # fallback в старый result_label\r\n                     self.window.result_label.setText(processed_text)\r\n-\r\n+    \r\n                 # нижний блок — обработанный текст (regex/LLM)\r\n                 if hasattr(self.window, \"set_processed_text\"):\r\n                     self.window.set_processed_text(processed_text)\r\n             except Exception:\r\n                 logger.debug(\"window text update failed\", exc_info=True)\r\n-\r\n+    \r\n             # 5) положить ОБРАБОТАННЫЙ текст в буфер обмена\r\n             self.clipboard.copy(processed_text)\r\n-\r\n+    \r\n             # авто-вставка текста через Ctrl+V (с ретраями внутри ClipboardManager)\r\n             self.clipboard.paste()\r\n-\r\n+    \r\n+            # 6) сохранить распознавание в отдельный текстовый лог с ротацией по ~3 МБ\r\n+            try:\r\n+                base_dir = Path(__file__).resolve().parents[2]\r\n+                log_dir = base_dir / \"logs\"\r\n+                log_dir.mkdir(parents=True, exist_ok=True)\r\n+                transcript_path = log_dir / \"transcripts.log\"\r\n+    \r\n+                # простая ротация: если файл больше 3 МБ — переименовать в transcripts_YYYYmmdd_HHMMSS.log\r\n+                max_size_bytes = 3 * 1024 * 1024\r\n+                if transcript_path.exists() and transcript_path.stat().st_size >= max_size_bytes:\r\n+                    ts = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\r\n+                    rotated = log_dir / f\"transcripts_{ts}.log\"\r\n+                    transcript_path.rename(rotated)\r\n+    \r\n+                # формат записи: время, сырой текст, обработанный текст\r\n+                with transcript_path.open(\"a\", encoding=\"utf-8\") as f:\r\n+                    f.write(\r\n+                        f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]\\\\n\"\r\n+                        f\"RAW: { (raw_text or '').strip() }\\\\n\"\r\n+                        f\"PROCESSED: { (processed_text or '').strip() }\\\\n\"\r\n+                        \"----------------------------------------\\\\n\"\r\n+                    )\r\n+            except Exception as exc:  # noqa: BLE001\r\n+                # не ломаем основной флоу, если что-то пошло не так с логом\r\n+                logger.exception(\"Failed to append transcript log: {}\", exc)\r\n+    \r\n             self.window.set_state(\"ready\")\r\n         except RuntimeError as exc:\r\n             # Осмысленные ошибки от распознавания (например, Groq API)\r\n             logger.error(\"Processing error: {}\", exc)\r\n"
                },
                {
                    "date": 1764456211724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -286,44 +286,44 @@\n         Читаем значения из UI, обновляем self.settings, сохраняем в config.yaml\r\n         и пересоздаём recognizer/postprocessor.\r\n         \"\"\"\r\n         from config.settings import AppSettings  # локальный импорт, чтобы избежать циклов\r\n-\r\n+    \r\n         rec = self.settings.recognition\r\n         post = self.settings.postprocess\r\n-\r\n+    \r\n         # 1) backend\r\n         backend_data = self.window.settings_backend_combo.currentData()\r\n         if backend_data in (\"groq\", \"openai\", \"local\"):\r\n             rec.backend = backend_data\r\n-\r\n+    \r\n         # 2) API keys / base URL\r\n         rec.groq.api_key = self.window.settings_groq_key.text().strip() or rec.groq.api_key\r\n         rec.openai.api_key = self.window.settings_openai_key.text().strip() or rec.openai.api_key\r\n         base_url = self.window.settings_openai_url.text().strip()\r\n         if base_url:\r\n             rec.openai.base_url = base_url\r\n-\r\n+    \r\n         # 3) postprocess\r\n         post.enabled = self.window.postprocess_enabled_checkbox.isChecked()\r\n-\r\n+    \r\n         # модели LLM: пишем в recognition.*.model_process и синхронизируем postprocess.*.model\r\n         groq_model_proc = self.window.postprocess_groq_model.text().strip()\r\n         if groq_model_proc:\r\n             rec.groq.model_process = groq_model_proc\r\n             post.groq.model = groq_model_proc\r\n-\r\n+    \r\n         openai_model_proc = self.window.postprocess_openai_model.text().strip()\r\n         if openai_model_proc:\r\n             rec.openai.model_process = openai_model_proc\r\n             post.openai.model = openai_model_proc\r\n-\r\n+    \r\n         # 4) сохранить всё в config.yaml\r\n         AppSettings.save_default(self.settings)\r\n-\r\n+    \r\n         # 5) пересоздать recognizer и postprocessor\r\n         self.recognizer = create_recognizer(self.settings.recognition)\r\n-\r\n+    \r\n         post_cfg = self.settings.postprocess\r\n         if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n             setattr(post_cfg.groq, \"api_key\", rec.groq.api_key)\r\n             if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n@@ -331,12 +331,28 @@\n         if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n             setattr(post_cfg.openai, \"api_key\", rec.openai.api_key)\r\n             if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n                 setattr(post_cfg.openai, \"model_process\", rec.openai.model_process)\r\n-\r\n+    \r\n         self.postprocessor = TextPostprocessor(post_cfg)\r\n-\r\n-        # 6) показать уведомление\r\n+    \r\n+        # 6) если теперь ключи заданы — убрать предупреждающую надпись\r\n+        backend = (self.settings.recognition.backend or \"groq\").lower()\r\n+        has_key = False\r\n+        if backend == \"groq\" and (self.settings.recognition.groq.api_key or \"\").strip():\r\n+            has_key = True\r\n+        elif backend == \"openai\" and (self.settings.recognition.openai.api_key or \"\").strip():\r\n+            has_key = True\r\n+    \r\n+        if has_key:\r\n+            # очищаем все текстовые блоки, чтобы не висело старое предупреждение\r\n+            if hasattr(self.window, \"set_raw_text\"):\r\n+                self.window.set_raw_text(\"\")\r\n+            if hasattr(self.window, \"set_processed_text\"):\r\n+                self.window.set_processed_text(\"\")\r\n+            self.window.result_label.setText(\"\")\r\n+    \r\n+        # 7) показать уведомление\r\n         self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n \r\n     # -------------------------------------------------------------- Lifecycle\r\n \r\n"
                }
            ],
            "date": 1764291847746,
            "name": "Commit-0",
            "content": "import sys\r\nfrom typing import Optional\r\n\r\nfrom PyQt6.QtWidgets import QApplication\r\n\r\nfrom config.settings import AppSettings\r\nfrom ui.floating_window import FloatingWindow\r\nfrom ui.system_tray import SystemTrayIcon\r\nfrom hotkey.hotkey_manager import HotKeyManager\r\nfrom audio.recorder import AudioRecorder\r\nfrom clipboard.clipboard_manager import ClipboardManager\r\nfrom recognition import create_recognizer\r\nfrom recognition.postprocessor import TextPostprocessor\r\nfrom utils.logger import setup_logging\r\n\r\n\r\nclass App:\r\n    \"\"\"\r\n    Main application class: wires UI, hotkeys, audio recorder, recognizer and clipboard.\r\n\r\n    MVP workflow:\r\n        global hotkey (record) down   -> start_recording()\r\n        global hotkey (record) up     -> stop_recording()\r\n        audio -> recognizer (Groq) -> postprocess -> clipboard.copy + paste\r\n    \"\"\"\r\n\r\n    def __init__(self) -> None:\r\n        self.qt_app = QApplication(sys.argv)\r\n\r\n        # Load settings and logging\r\n        self.settings = AppSettings.load_default()\r\n        setup_logging(self.settings.logging)\r\n\r\n        # Core components\r\n        self.window = FloatingWindow(self.settings.ui)\r\n        self.tray = SystemTrayIcon(self.window, self.settings.app)\r\n        self.clipboard = ClipboardManager()\r\n        self.audio_recorder = AudioRecorder(self.settings.audio)\r\n        self.recognizer = create_recognizer(self.settings.recognition)\r\n        self.postprocessor = TextPostprocessor(self.settings.postprocess)\r\n\r\n        # State\r\n        self._is_recording: bool = False\r\n\r\n        # Hotkeys\r\n        self.hotkeys = HotKeyManager(\r\n            record_hotkey=self.settings.hotkeys.record,\r\n            cancel_hotkey=self.settings.hotkeys.cancel,\r\n            toggle_window_hotkey=self.settings.hotkeys.toggle_window,\r\n            toggle_debug_hotkey=self.settings.hotkeys.toggle_debug,\r\n            on_record_press=self.start_recording,\r\n            on_record_release=self.stop_recording,\r\n            on_cancel=self.cancel_recording,\r\n            on_toggle_window=self.toggle_window_visibility,\r\n            on_toggle_debug=self.toggle_debug_mode,\r\n        )\r\n\r\n        # Wire UI signals\r\n        self.window.settings_requested.connect(self.open_settings_dialog)\r\n        self.window.exit_requested.connect(self.quit)\r\n        self.tray.show_window_requested.connect(self.show_window)\r\n        self.tray.settings_requested.connect(self.open_settings_dialog)\r\n        self.tray.toggle_debug_requested.connect(self.toggle_debug_mode)\r\n        self.tray.exit_requested.connect(self.quit)\r\n\r\n    # --------------------------------------------------------------------- UI\r\n\r\n    def show_window(self) -> None:\r\n        self.window.show()\r\n        self.window.raise_()\r\n        self.window.activateWindow()\r\n\r\n    def toggle_window_visibility(self) -> None:\r\n        if self.window.isVisible():\r\n            self.window.hide()\r\n        else:\r\n            self.show_window()\r\n\r\n    def open_settings_dialog(self) -> None:\r\n        # Placeholder: real implementation will open SettingsDialog\r\n        self.window.show_message(\"Settings dialog is not implemented yet (MVP skeleton).\")\r\n\r\n    # ----------------------------------------------------------------- Hotkeys\r\n\r\n    def start_recording(self) -> None:\r\n        if self._is_recording:\r\n            return\r\n        self._is_recording = True\r\n        self.window.set_state(\"recording\")\r\n\r\n        def on_finished(audio_data):\r\n            # Этот колбэк вызывается из потока рекордера.\r\n            # Для MVP просто передаём данные в обработку синхронно.\r\n            self._process_audio(audio_data)\r\n\r\n        self.audio_recorder.start(on_finished=on_finished)\r\n\r\n    def stop_recording(self) -> None:\r\n        if not self._is_recording:\r\n            return\r\n        self._is_recording = False\r\n        self.audio_recorder.stop()\r\n\r\n    def cancel_recording(self) -> None:\r\n        if not self._is_recording:\r\n            return\r\n        self._is_recording = False\r\n        self.audio_recorder.cancel()\r\n        self.window.set_state(\"idle\")\r\n\r\n    # ----------------------------------------------------------- Processing\r\n\r\n    def _process_audio(self, audio_data) -> None:\r\n        \"\"\"Synchronous processing for MVP; later can be moved to worker thread.\"\"\"\r\n        try:\r\n            self.window.set_state(\"processing\")\r\n            text = self.recognizer.transcribe(audio_data)\r\n            text = self.postprocessor.process(text)\r\n            self.clipboard.copy(text)\r\n            self.clipboard.paste()\r\n            self.window.set_state(\"ready\")\r\n        except Exception as exc:  # noqa: BLE001\r\n            from loguru import logger\r\n\r\n            logger.exception(\"Error during processing: {}\", exc)\r\n            self.window.set_state(\"error\")\r\n            self.window.show_message(\"Error during recognition. See logs.\")\r\n\r\n    # -------------------------------------------------------------- Debug\r\n\r\n    def toggle_debug_mode(self) -> None:\r\n        # Placeholder: will reconfigure logging level later\r\n        self.window.show_message(\"Toggle debug (not fully implemented yet).\")\r\n\r\n    # -------------------------------------------------------------- Lifecycle\r\n\r\n    def quit(self) -> None:\r\n        self.hotkeys.stop()\r\n        self.qt_app.quit()\r\n\r\n    def run(self) -> None:\r\n        self.hotkeys.start()\r\n        self.show_window()\r\n        sys.exit(self.qt_app.exec())\r\n\r\n\r\ndef main() -> None:\r\n    app = App()\r\n    app.run()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()"
        }
    ]
}