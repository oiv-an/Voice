{
    "sourceFile": "src/main.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 22,
            "patches": [
                {
                    "date": 1764291847746,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764294103165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,10 +115,24 @@\n         try:\r\n             self.window.set_state(\"processing\")\r\n             text = self.recognizer.transcribe(audio_data)\r\n             text = self.postprocessor.process(text)\r\n+\r\n+            # показать распознанный текст в окне\r\n+            try:\r\n+                # result_label добавлен во FloatingWindow\r\n+                self.window.result_label.setText(text)\r\n+            except Exception:\r\n+                # если по какой-то причине нет result_label — просто игнорируем\r\n+                pass\r\n+\r\n+            # положить текст в буфер обмена\r\n             self.clipboard.copy(text)\r\n+\r\n+            # авто-вставка сейчас отключена (paste() — заглушка),\r\n+            # пользователь вставляет текст вручную через Ctrl+V\r\n             self.clipboard.paste()\r\n+\r\n             self.window.set_state(\"ready\")\r\n         except Exception as exc:  # noqa: BLE001\r\n             from loguru import logger\r\n \r\n"
                },
                {
                    "date": 1764295812842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,11 +76,33 @@\n         else:\r\n             self.show_window()\r\n \r\n     def open_settings_dialog(self) -> None:\r\n-        # Placeholder: real implementation will open SettingsDialog\r\n-        self.window.show_message(\"Settings dialog is not implemented yet (MVP skeleton).\")\r\n+        \"\"\"\r\n+        Открыть диалог настроек:\r\n+        - выбор backend'а (Groq / OpenAI)\r\n+        - ввод API-ключей и base URL\r\n+        - обновление настроек и пересоздание recognizer'а\r\n+        \"\"\"\r\n+        from ui.settings_dialog import SettingsDialog\r\n \r\n+        dlg = SettingsDialog(self.settings, parent=self.window)\r\n+        if dlg.exec() != dlg.DialogCode.Accepted:\r\n+            return\r\n+\r\n+        new_settings = dlg.get_result()\r\n+        if new_settings is None:\r\n+            return\r\n+\r\n+        # обновляем настройки в приложении\r\n+        self.settings = new_settings\r\n+\r\n+        # пересоздаём recognizer с новыми параметрами\r\n+        self.recognizer = create_recognizer(self.settings.recognition)\r\n+\r\n+        # сообщаем пользователю\r\n+        self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n+\r\n     # ----------------------------------------------------------------- Hotkeys\r\n \r\n     def start_recording(self) -> None:\r\n         if self._is_recording:\r\n"
                },
                {
                    "date": 1764295922499,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,13 +70,19 @@\n         self.window.raise_()\r\n         self.window.activateWindow()\r\n \r\n     def toggle_window_visibility(self) -> None:\r\n-        if self.window.isVisible():\r\n-            self.window.hide()\r\n-        else:\r\n-            self.show_window()\r\n+        \"\"\"\r\n+        Горячая клавиша \"Показать/скрыть окно\".\r\n \r\n+        Для твоего сценария окно должно быть ВСЕГДА видно, поэтому\r\n+        мы больше не будем его прятать, а только:\r\n+        - если оно свернуто в компактный режим — разворачивать,\r\n+        - если оно где-то \"потерялось\" — показывать и поднимать наверх.\r\n+        \"\"\"\r\n+        # просто гарантируем, что окно показано и на переднем плане\r\n+        self.show_window()\r\n+\r\n     def open_settings_dialog(self) -> None:\r\n         \"\"\"\r\n         Открыть диалог настроек:\r\n         - выбор backend'а (Groq / OpenAI)\r\n"
                },
                {
                    "date": 1764300224731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,31 +83,41 @@\n         self.show_window()\r\n \r\n     def open_settings_dialog(self) -> None:\r\n         \"\"\"\r\n-        Открыть диалог настроек:\r\n-        - выбор backend'а (Groq / OpenAI)\r\n-        - ввод API-ключей и base URL\r\n-        - обновление настроек и пересоздание recognizer'а\r\n+        Открыть панель настроек внутри основного окна.\r\n+\r\n+        ВАЖНО: все значения берём/кладём только в config.yaml через AppSettings.\r\n         \"\"\"\r\n-        from ui.settings_dialog import SettingsDialog\r\n+        # показать окно\r\n+        self.show_window()\r\n \r\n-        dlg = SettingsDialog(self.settings, parent=self.window)\r\n-        if dlg.exec() != dlg.DialogCode.Accepted:\r\n-            return\r\n+        # заполнить UI текущими значениями из self.settings\r\n+        rec = self.settings.recognition\r\n+        post = self.settings.postprocess\r\n \r\n-        new_settings = dlg.get_result()\r\n-        if new_settings is None:\r\n-            return\r\n+        # backend\r\n+        backend_value = (rec.backend or \"groq\").lower()\r\n+        idx = self.window.settings_backend_combo.findData(backend_value)\r\n+        if idx >= 0:\r\n+            self.window.settings_backend_combo.setCurrentIndex(idx)\r\n \r\n-        # обновляем настройки в приложении\r\n-        self.settings = new_settings\r\n+        # API keys / base URL\r\n+        self.window.settings_groq_key.setText(rec.groq.api_key or \"\")\r\n+        self.window.settings_openai_key.setText(rec.openai.api_key or \"\")\r\n+        self.window.settings_openai_url.setText(rec.openai.base_url or \"\")\r\n \r\n-        # пересоздаём recognizer с новыми параметрами\r\n-        self.recognizer = create_recognizer(self.settings.recognition)\r\n+        # postprocess\r\n+        self.window.postprocess_enabled_checkbox.setChecked(post.enabled)\r\n+        self.window.postprocess_groq_model.setText(\r\n+            (post.groq.model or \"mixtral-8x7b-32768\")\r\n+        )\r\n+        self.window.postprocess_openai_model.setText(\r\n+            (post.openai.model or \"gpt-4\")\r\n+        )\r\n \r\n-        # сообщаем пользователю\r\n-        self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n+        # переключаем окно в режим настроек\r\n+        self.window._enter_settings_mode()\r\n \r\n     # ----------------------------------------------------------------- Hotkeys\r\n \r\n     def start_recording(self) -> None:\r\n"
                },
                {
                    "date": 1764300336323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,8 +56,9 @@\n         )\r\n \r\n         # Wire UI signals\r\n         self.window.settings_requested.connect(self.open_settings_dialog)\r\n+        self.window.settings_save_requested.connect(self._on_settings_save_requested)\r\n         self.window.exit_requested.connect(self.quit)\r\n         self.tray.show_window_requested.connect(self.show_window)\r\n         self.tray.settings_requested.connect(self.open_settings_dialog)\r\n         self.tray.toggle_debug_requested.connect(self.toggle_debug_mode)\r\n"
                },
                {
                    "date": 1764300531469,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -184,8 +184,50 @@\n     def toggle_debug_mode(self) -> None:\r\n         # Placeholder: will reconfigure logging level later\r\n         self.window.show_message(\"Toggle debug (not fully implemented yet).\")\r\n \r\n+    # ----------------------------------------------------------- Settings save\r\n+\r\n+    def _on_settings_save_requested(self) -> None:\r\n+        \"\"\"\r\n+        Пользователь нажал «Сохранить» в панели настроек.\r\n+        Читаем значения из UI, обновляем self.settings, сохраняем в config.yaml\r\n+        и пересоздаём recognizer/postprocessor.\r\n+        \"\"\"\r\n+        from config.settings import AppSettings  # локальный импорт, чтобы избежать циклов\r\n+\r\n+        rec = self.settings.recognition\r\n+        post = self.settings.postprocess\r\n+\r\n+        # 1) backend\r\n+        backend_data = self.window.settings_backend_combo.currentData()\r\n+        if backend_data in (\"groq\", \"openai\", \"local\"):\r\n+            rec.backend = backend_data\r\n+\r\n+        # 2) API keys / base URL\r\n+        rec.groq.api_key = self.window.settings_groq_key.text().strip()\r\n+        rec.openai.api_key = self.window.settings_openai_key.text().strip()\r\n+        base_url = self.window.settings_openai_url.text().strip()\r\n+        if base_url:\r\n+            rec.openai.base_url = base_url\r\n+\r\n+        # 3) postprocess\r\n+        post.enabled = self.window.postprocess_enabled_checkbox.isChecked()\r\n+        groq_model = self.window.postprocess_groq_model.text().strip()\r\n+        openai_model = self.window.postprocess_openai_model.text().strip()\r\n+        post.groq.model = groq_model or \"mixtral-8x7b-32768\"\r\n+        post.openai.model = openai_model or \"gpt-4\"\r\n+\r\n+        # 4) сохранить всё в config.yaml\r\n+        AppSettings.save_default(self.settings)\r\n+\r\n+        # 5) пересоздать recognizer и postprocessor\r\n+        self.recognizer = create_recognizer(self.settings.recognition)\r\n+        self.postprocessor = TextPostprocessor(self.settings.postprocess)\r\n+\r\n+        # 6) показать уведомление\r\n+        self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n+\r\n     # -------------------------------------------------------------- Lifecycle\r\n \r\n     def quit(self) -> None:\r\n         self.hotkeys.stop()\r\n"
                },
                {
                    "date": 1764300667772,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,8 +38,21 @@\n         self.audio_recorder = AudioRecorder(self.settings.audio)\r\n         self.recognizer = create_recognizer(self.settings.recognition)\r\n         self.postprocessor = TextPostprocessor(self.settings.postprocess)\r\n \r\n+        # Первое сообщение: если нет ключа для текущего backend'а — подсказка пользователю\r\n+        backend = (self.settings.recognition.backend or \"groq\").lower()\r\n+        missing_key = False\r\n+        if backend == \"groq\" and not (self.settings.recognition.groq.api_key or \"\").strip():\r\n+            missing_key = True\r\n+        elif backend == \"openai\" and not (self.settings.recognition.openai.api_key or \"\").strip():\r\n+            missing_key = True\r\n+\r\n+        if missing_key:\r\n+            self.window.result_label.setText(\r\n+                \"Добавьте API‑ключ в настройках (⚙️) перед использованием распознавания.\"\r\n+            )\r\n+\r\n         # State\r\n         self._is_recording: bool = False\r\n \r\n         # Hotkeys\r\n"
                },
                {
                    "date": 1764301634152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,8 +163,10 @@\n     # ----------------------------------------------------------- Processing\r\n \r\n     def _process_audio(self, audio_data) -> None:\r\n         \"\"\"Synchronous processing for MVP; later can be moved to worker thread.\"\"\"\r\n+        from loguru import logger\r\n+\r\n         try:\r\n             self.window.set_state(\"processing\")\r\n             text = self.recognizer.transcribe(audio_data)\r\n             text = self.postprocessor.process(text)\r\n@@ -174,24 +176,27 @@\n                 # result_label добавлен во FloatingWindow\r\n                 self.window.result_label.setText(text)\r\n             except Exception:\r\n                 # если по какой-то причине нет result_label — просто игнорируем\r\n-                pass\r\n+                logger.debug(\"result_label is not available on window\")\r\n \r\n             # положить текст в буфер обмена\r\n             self.clipboard.copy(text)\r\n \r\n-            # авто-вставка сейчас отключена (paste() — заглушка),\r\n-            # пользователь вставляет текст вручную через Ctrl+V\r\n+            # авто-вставка текста через Ctrl+V (с ретраями внутри ClipboardManager)\r\n             self.clipboard.paste()\r\n \r\n             self.window.set_state(\"ready\")\r\n+        except RuntimeError as exc:\r\n+            # Осмысленные ошибки от распознавания (например, Groq API)\r\n+            logger.error(\"Processing error: {}\", exc)\r\n+            self.window.set_state(\"error\")\r\n+            # Показываем пользователю человекочитаемое сообщение\r\n+            self.window.show_message(str(exc))\r\n         except Exception as exc:  # noqa: BLE001\r\n-            from loguru import logger\r\n-\r\n-            logger.exception(\"Error during processing: {}\", exc)\r\n+            logger.exception(\"Unexpected error during processing: {}\", exc)\r\n             self.window.set_state(\"error\")\r\n-            self.window.show_message(\"Error during recognition. See logs.\")\r\n+            self.window.show_message(\"Неизвестная ошибка распознавания. См. логи.\")\r\n \r\n     # -------------------------------------------------------------- Debug\r\n \r\n     def toggle_debug_mode(self) -> None:\r\n"
                },
                {
                    "date": 1764301744720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,15 +121,17 @@\n         self.window.settings_openai_url.setText(rec.openai.base_url or \"\")\r\n \r\n         # postprocess\r\n         self.window.postprocess_enabled_checkbox.setChecked(post.enabled)\r\n-        self.window.postprocess_groq_model.setText(\r\n-            (post.groq.model or \"mixtral-8x7b-32768\")\r\n-        )\r\n-        self.window.postprocess_openai_model.setText(\r\n-            (post.openai.model or \"gpt-4\")\r\n-        )\r\n \r\n+        # Если в конфиге пустые строки, подставляем дефолты,\r\n+        # чтобы поля в UI были уже заполнены при первом открытии.\r\n+        groq_model = (post.groq.model or \"\").strip() or \"mixtral-8x7b-32768\"\r\n+        openai_model = (post.openai.model or \"\").strip() or \"gpt-4\"\r\n+\r\n+        self.window.postprocess_groq_model.setText(groq_model)\r\n+        self.window.postprocess_openai_model.setText(openai_model)\r\n+\r\n         # переключаем окно в режим настроек\r\n         self.window._enter_settings_mode()\r\n \r\n     # ----------------------------------------------------------------- Hotkeys\r\n"
                },
                {
                    "date": 1764302203231,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,10 +124,13 @@\n         self.window.postprocess_enabled_checkbox.setChecked(post.enabled)\r\n \r\n         # Если в конфиге пустые строки, подставляем дефолты,\r\n         # чтобы поля в UI были уже заполнены при первом открытии.\r\n-        groq_model = (post.groq.model or \"\").strip() or \"mixtral-8x7b-32768\"\r\n-        openai_model = (post.openai.model or \"\").strip() or \"gpt-4\"\r\n+        # По твоему запросу:\r\n+        #   - Groq postprocess model:   llama-3.1-70b-versatile\r\n+        #   - OpenAI postprocess model: gpt-4.1\r\n+        groq_model = (post.groq.model or \"\").strip() or \"llama-3.1-70b-versatile\"\r\n+        openai_model = (post.openai.model or \"\").strip() or \"gpt-4.1\"\r\n \r\n         self.window.postprocess_groq_model.setText(groq_model)\r\n         self.window.postprocess_openai_model.setText(openai_model)\r\n \r\n"
                },
                {
                    "date": 1764302316559,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,12 +125,12 @@\n \r\n         # Если в конфиге пустые строки, подставляем дефолты,\r\n         # чтобы поля в UI были уже заполнены при первом открытии.\r\n         # По твоему запросу:\r\n-        #   - Groq postprocess model:   llama-3.1-70b-versatile\r\n-        #   - OpenAI postprocess model: gpt-4.1\r\n-        groq_model = (post.groq.model or \"\").strip() or \"llama-3.1-70b-versatile\"\r\n-        openai_model = (post.openai.model or \"\").strip() or \"gpt-4.1\"\r\n+        #   - Groq postprocess model:   mixtral-8x7b-32768\r\n+        #   - OpenAI postprocess model: gpt-5.1\r\n+        groq_model = (post.groq.model or \"\").strip() or \"mixtral-8x7b-32768\"\r\n+        openai_model = (post.openai.model or \"\").strip() or \"gpt-5.1\"\r\n \r\n         self.window.postprocess_groq_model.setText(groq_model)\r\n         self.window.postprocess_openai_model.setText(openai_model)\r\n \r\n"
                },
                {
                    "date": 1764303019785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -172,21 +172,44 @@\n         from loguru import logger\r\n \r\n         try:\r\n             self.window.set_state(\"processing\")\r\n-            text = self.recognizer.transcribe(audio_data)\r\n-            text = self.postprocessor.process(text)\r\n+            # 1) сырой текст от Whisper\r\n+            raw_text = self.recognizer.transcribe(audio_data)\r\n \r\n-            # показать распознанный текст в окне\r\n+            # 2) regex-очистка (базовый препроцессинг всегда)\r\n+            from recognition.postprocessor import TextPostprocessor as TP  # локальный импорт для статик-метода\r\n+            regex_text = TP._simple_cleanup(raw_text or \"\")\r\n+\r\n+            # 3) LLM-постпроцессинг (если включён в конфиге)\r\n+            processed_text = regex_text\r\n             try:\r\n-                # result_label добавлен во FloatingWindow\r\n-                self.window.result_label.setText(text)\r\n+                processed_text = self.postprocessor.process(raw_text or \"\")\r\n+            except RuntimeError as exc:\r\n+                # осмысленные ошибки LLM\r\n+                logger.error(\"LLM postprocess error: {}\", exc)\r\n+                self.window.show_message(str(exc))\r\n+            except Exception as exc:  # noqa: BLE001\r\n+                logger.exception(\"Unexpected LLM postprocess error: {}\", exc)\r\n+                self.window.show_message(\"Ошибка LLM-постпроцессинга. См. логи.\")\r\n+\r\n+            # 4) показать оба варианта в окне\r\n+            try:\r\n+                # верхний блок — сырой текст от Whisper\r\n+                if hasattr(self.window, \"set_raw_text\"):\r\n+                    self.window.set_raw_text(raw_text or \"\")\r\n+                else:\r\n+                    # fallback в старый result_label\r\n+                    self.window.result_label.setText(processed_text)\r\n+\r\n+                # нижний блок — обработанный текст (regex/LLM)\r\n+                if hasattr(self.window, \"set_processed_text\"):\r\n+                    self.window.set_processed_text(processed_text)\r\n             except Exception:\r\n-                # если по какой-то причине нет result_label — просто игнорируем\r\n-                logger.debug(\"result_label is not available on window\")\r\n+                logger.debug(\"window text update failed\", exc_info=True)\r\n \r\n-            # положить текст в буфер обмена\r\n-            self.clipboard.copy(text)\r\n+            # 5) положить ОБРАБОТАННЫЙ текст в буфер обмена\r\n+            self.clipboard.copy(processed_text)\r\n \r\n             # авто-вставка текста через Ctrl+V (с ретраями внутри ClipboardManager)\r\n             self.clipboard.paste()\r\n \r\n"
                },
                {
                    "date": 1764305709575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -249,28 +249,46 @@\n         if backend_data in (\"groq\", \"openai\", \"local\"):\r\n             rec.backend = backend_data\r\n \r\n         # 2) API keys / base URL\r\n-        rec.groq.api_key = self.window.settings_groq_key.text().strip()\r\n-        rec.openai.api_key = self.window.settings_openai_key.text().strip()\r\n+        rec.groq.api_key = self.window.settings_groq_key.text().strip() or rec.groq.api_key\r\n+        rec.openai.api_key = self.window.settings_openai_key.text().strip() or rec.openai.api_key\r\n         base_url = self.window.settings_openai_url.text().strip()\r\n         if base_url:\r\n             rec.openai.base_url = base_url\r\n \r\n         # 3) postprocess\r\n         post.enabled = self.window.postprocess_enabled_checkbox.isChecked()\r\n-        groq_model = self.window.postprocess_groq_model.text().strip()\r\n-        openai_model = self.window.postprocess_openai_model.text().strip()\r\n-        post.groq.model = groq_model or \"mixtral-8x7b-32768\"\r\n-        post.openai.model = openai_model or \"gpt-4\"\r\n \r\n+        # модели LLM: пишем в recognition.*.model_process и синхронизируем postprocess.*.model\r\n+        groq_model_proc = self.window.postprocess_groq_model.text().strip()\r\n+        if groq_model_proc:\r\n+            rec.groq.model_process = groq_model_proc\r\n+            post.groq.model = groq_model_proc\r\n+\r\n+        openai_model_proc = self.window.postprocess_openai_model.text().strip()\r\n+        if openai_model_proc:\r\n+            rec.openai.model_process = openai_model_proc\r\n+            post.openai.model = openai_model_proc\r\n+\r\n         # 4) сохранить всё в config.yaml\r\n         AppSettings.save_default(self.settings)\r\n \r\n         # 5) пересоздать recognizer и postprocessor\r\n         self.recognizer = create_recognizer(self.settings.recognition)\r\n-        self.postprocessor = TextPostprocessor(self.settings.postprocess)\r\n \r\n+        post_cfg = self.settings.postprocess\r\n+        if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n+            post_cfg.groq.api_key = rec.groq.api_key\r\n+            if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n+                setattr(post_cfg.groq, \"model_process\", rec.groq.model_process)\r\n+        if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n+            post_cfg.openai.api_key = rec.openai.api_key\r\n+            if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n+                setattr(post_cfg.openai, \"model_process\", rec.openai.model_process)\r\n+\r\n+        self.postprocessor = TextPostprocessor(post_cfg)\r\n+\r\n         # 6) показать уведомление\r\n         self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n \r\n     # -------------------------------------------------------------- Lifecycle\r\n"
                },
                {
                    "date": 1764305899180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,10 +36,29 @@\n         self.tray = SystemTrayIcon(self.window, self.settings.app)\r\n         self.clipboard = ClipboardManager()\r\n         self.audio_recorder = AudioRecorder(self.settings.audio)\r\n         self.recognizer = create_recognizer(self.settings.recognition)\r\n-        self.postprocessor = TextPostprocessor(self.settings.postprocess)\r\n \r\n+        # Постпроцессинг текста.\r\n+        # ВАЖНО: сразу прокидываем в postprocess.* тот же ключ и model_process,\r\n+        # что и в recognition.*, чтобы LLM работал уже при первом запуске.\r\n+        post_cfg = self.settings.postprocess\r\n+        rec_cfg = self.settings.recognition\r\n+\r\n+        if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n+            # один ключ Groq: берём из recognition.groq.api_key\r\n+            setattr(post_cfg.groq, \"api_key\", rec_cfg.groq.api_key)\r\n+            # модель LLM: из recognition.groq.model_process\r\n+            if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n+                setattr(post_cfg.groq, \"model_process\", rec_cfg.groq.model_process)\r\n+\r\n+        if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n+            setattr(post_cfg.openai, \"api_key\", rec_cfg.openai.api_key)\r\n+            if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n+                setattr(post_cfg.openai, \"model_process\", rec_cfg.openai.model_process)\r\n+\r\n+        self.postprocessor = TextPostprocessor(post_cfg)\r\n+\r\n         # Первое сообщение: если нет ключа для текущего backend'а — подсказка пользователю\r\n         backend = (self.settings.recognition.backend or \"groq\").lower()\r\n         missing_key = False\r\n         if backend == \"groq\" and not (self.settings.recognition.groq.api_key or \"\").strip():\r\n@@ -277,13 +296,13 @@\n         self.recognizer = create_recognizer(self.settings.recognition)\r\n \r\n         post_cfg = self.settings.postprocess\r\n         if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n-            post_cfg.groq.api_key = rec.groq.api_key\r\n+            setattr(post_cfg.groq, \"api_key\", rec.groq.api_key)\r\n             if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n                 setattr(post_cfg.groq, \"model_process\", rec.groq.model_process)\r\n         if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n-            post_cfg.openai.api_key = rec.openai.api_key\r\n+            setattr(post_cfg.openai, \"api_key\", rec.openai.api_key)\r\n             if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n                 setattr(post_cfg.openai, \"model_process\", rec.openai.model_process)\r\n \r\n         self.postprocessor = TextPostprocessor(post_cfg)\r\n"
                },
                {
                    "date": 1764422294029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -184,22 +184,24 @@\n         self.audio_recorder.cancel()\r\n         self.window.set_state(\"idle\")\r\n \r\n     # ----------------------------------------------------------- Processing\r\n-\r\n+    \r\n     def _process_audio(self, audio_data) -> None:\r\n         \"\"\"Synchronous processing for MVP; later can be moved to worker thread.\"\"\"\r\n         from loguru import logger\r\n-\r\n+        from pathlib import Path\r\n+        from datetime import datetime\r\n+    \r\n         try:\r\n             self.window.set_state(\"processing\")\r\n             # 1) сырой текст от Whisper\r\n             raw_text = self.recognizer.transcribe(audio_data)\r\n-\r\n+    \r\n             # 2) regex-очистка (базовый препроцессинг всегда)\r\n             from recognition.postprocessor import TextPostprocessor as TP  # локальный импорт для статик-метода\r\n             regex_text = TP._simple_cleanup(raw_text or \"\")\r\n-\r\n+    \r\n             # 3) LLM-постпроцессинг (если включён в конфиге)\r\n             processed_text = regex_text\r\n             try:\r\n                 processed_text = self.postprocessor.process(raw_text or \"\")\r\n@@ -209,30 +211,56 @@\n                 self.window.show_message(str(exc))\r\n             except Exception as exc:  # noqa: BLE001\r\n                 logger.exception(\"Unexpected LLM postprocess error: {}\", exc)\r\n                 self.window.show_message(\"Ошибка LLM-постпроцессинга. См. логи.\")\r\n-\r\n+    \r\n             # 4) показать оба варианта в окне\r\n             try:\r\n                 # верхний блок — сырой текст от Whisper\r\n                 if hasattr(self.window, \"set_raw_text\"):\r\n                     self.window.set_raw_text(raw_text or \"\")\r\n                 else:\r\n                     # fallback в старый result_label\r\n                     self.window.result_label.setText(processed_text)\r\n-\r\n+    \r\n                 # нижний блок — обработанный текст (regex/LLM)\r\n                 if hasattr(self.window, \"set_processed_text\"):\r\n                     self.window.set_processed_text(processed_text)\r\n             except Exception:\r\n                 logger.debug(\"window text update failed\", exc_info=True)\r\n-\r\n+    \r\n             # 5) положить ОБРАБОТАННЫЙ текст в буфер обмена\r\n             self.clipboard.copy(processed_text)\r\n-\r\n+    \r\n             # авто-вставка текста через Ctrl+V (с ретраями внутри ClipboardManager)\r\n             self.clipboard.paste()\r\n-\r\n+    \r\n+            # 6) сохранить распознавание в отдельный текстовый лог с ротацией по ~3 МБ\r\n+            try:\r\n+                base_dir = Path(__file__).resolve().parents[2]\r\n+                log_dir = base_dir / \"logs\"\r\n+                log_dir.mkdir(parents=True, exist_ok=True)\r\n+                transcript_path = log_dir / \"transcripts.log\"\r\n+    \r\n+                # простая ротация: если файл больше 3 МБ — переименовать в transcripts_YYYYmmdd_HHMMSS.log\r\n+                max_size_bytes = 3 * 1024 * 1024\r\n+                if transcript_path.exists() and transcript_path.stat().st_size >= max_size_bytes:\r\n+                    ts = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\r\n+                    rotated = log_dir / f\"transcripts_{ts}.log\"\r\n+                    transcript_path.rename(rotated)\r\n+    \r\n+                # формат записи: время, сырой текст, обработанный текст\r\n+                with transcript_path.open(\"a\", encoding=\"utf-8\") as f:\r\n+                    f.write(\r\n+                        f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]\\\\n\"\r\n+                        f\"RAW: { (raw_text or '').strip() }\\\\n\"\r\n+                        f\"PROCESSED: { (processed_text or '').strip() }\\\\n\"\r\n+                        \"----------------------------------------\\\\n\"\r\n+                    )\r\n+            except Exception as exc:  # noqa: BLE001\r\n+                # не ломаем основной флоу, если что-то пошло не так с логом\r\n+                logger.exception(\"Failed to append transcript log: {}\", exc)\r\n+    \r\n             self.window.set_state(\"ready\")\r\n         except RuntimeError as exc:\r\n             # Осмысленные ошибки от распознавания (например, Groq API)\r\n             logger.error(\"Processing error: {}\", exc)\r\n"
                },
                {
                    "date": 1764456211724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -286,44 +286,44 @@\n         Читаем значения из UI, обновляем self.settings, сохраняем в config.yaml\r\n         и пересоздаём recognizer/postprocessor.\r\n         \"\"\"\r\n         from config.settings import AppSettings  # локальный импорт, чтобы избежать циклов\r\n-\r\n+    \r\n         rec = self.settings.recognition\r\n         post = self.settings.postprocess\r\n-\r\n+    \r\n         # 1) backend\r\n         backend_data = self.window.settings_backend_combo.currentData()\r\n         if backend_data in (\"groq\", \"openai\", \"local\"):\r\n             rec.backend = backend_data\r\n-\r\n+    \r\n         # 2) API keys / base URL\r\n         rec.groq.api_key = self.window.settings_groq_key.text().strip() or rec.groq.api_key\r\n         rec.openai.api_key = self.window.settings_openai_key.text().strip() or rec.openai.api_key\r\n         base_url = self.window.settings_openai_url.text().strip()\r\n         if base_url:\r\n             rec.openai.base_url = base_url\r\n-\r\n+    \r\n         # 3) postprocess\r\n         post.enabled = self.window.postprocess_enabled_checkbox.isChecked()\r\n-\r\n+    \r\n         # модели LLM: пишем в recognition.*.model_process и синхронизируем postprocess.*.model\r\n         groq_model_proc = self.window.postprocess_groq_model.text().strip()\r\n         if groq_model_proc:\r\n             rec.groq.model_process = groq_model_proc\r\n             post.groq.model = groq_model_proc\r\n-\r\n+    \r\n         openai_model_proc = self.window.postprocess_openai_model.text().strip()\r\n         if openai_model_proc:\r\n             rec.openai.model_process = openai_model_proc\r\n             post.openai.model = openai_model_proc\r\n-\r\n+    \r\n         # 4) сохранить всё в config.yaml\r\n         AppSettings.save_default(self.settings)\r\n-\r\n+    \r\n         # 5) пересоздать recognizer и postprocessor\r\n         self.recognizer = create_recognizer(self.settings.recognition)\r\n-\r\n+    \r\n         post_cfg = self.settings.postprocess\r\n         if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n             setattr(post_cfg.groq, \"api_key\", rec.groq.api_key)\r\n             if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n@@ -331,12 +331,28 @@\n         if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n             setattr(post_cfg.openai, \"api_key\", rec.openai.api_key)\r\n             if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n                 setattr(post_cfg.openai, \"model_process\", rec.openai.model_process)\r\n-\r\n+    \r\n         self.postprocessor = TextPostprocessor(post_cfg)\r\n-\r\n-        # 6) показать уведомление\r\n+    \r\n+        # 6) если теперь ключи заданы — убрать предупреждающую надпись\r\n+        backend = (self.settings.recognition.backend or \"groq\").lower()\r\n+        has_key = False\r\n+        if backend == \"groq\" and (self.settings.recognition.groq.api_key or \"\").strip():\r\n+            has_key = True\r\n+        elif backend == \"openai\" and (self.settings.recognition.openai.api_key or \"\").strip():\r\n+            has_key = True\r\n+    \r\n+        if has_key:\r\n+            # очищаем все текстовые блоки, чтобы не висело старое предупреждение\r\n+            if hasattr(self.window, \"set_raw_text\"):\r\n+                self.window.set_raw_text(\"\")\r\n+            if hasattr(self.window, \"set_processed_text\"):\r\n+                self.window.set_processed_text(\"\")\r\n+            self.window.result_label.setText(\"\")\r\n+    \r\n+        # 7) показать уведомление\r\n         self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n \r\n     # -------------------------------------------------------------- Lifecycle\r\n \r\n"
                },
                {
                    "date": 1764458293169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n \r\n     MVP workflow:\r\n         global hotkey (record) down   -> start_recording()\r\n         global hotkey (record) up     -> stop_recording()\r\n-        audio -> recognizer (Groq) -> postprocess -> clipboard.copy + paste\r\n+        audio -> recognizer (Groq/GigaAM) -> postprocess -> clipboard.copy + paste\r\n     \"\"\"\r\n \r\n     def __init__(self) -> None:\r\n         self.qt_app = QApplication(sys.argv)\r\n@@ -73,8 +73,64 @@\n \r\n         # State\r\n         self._is_recording: bool = False\r\n \r\n+        # Worker thread for heavy audio processing (GigaAM / Groq / LLM)\r\n+        from PyQt6.QtCore import QObject, QThread, pyqtSignal\r\n+\r\n+        class _ProcessingWorker(QObject):\r\n+            finished = pyqtSignal()\r\n+            error = pyqtSignal(str)\r\n+            result_ready = pyqtSignal(str, str)  # raw_text, processed_text\r\n+\r\n+            def __init__(self, app_ref: \"App\", audio_data) -> None:\r\n+                super().__init__()\r\n+                self._app_ref = app_ref\r\n+                self._audio_data = audio_data\r\n+\r\n+            def run(self) -> None:\r\n+                \"\"\"\r\n+                Выполняется в отдельном потоке:\r\n+                - распознавание (Groq/GigaAM)\r\n+                - regex + LLM постобработка\r\n+                Никаких Qt-объектов/виджетов здесь не трогаем.\r\n+                \"\"\"\r\n+                from loguru import logger\r\n+                from recognition.postprocessor import TextPostprocessor as TP\r\n+\r\n+                try:\r\n+                    raw_text = self._app_ref.recognizer.transcribe(self._audio_data)\r\n+                    regex_text = TP._simple_cleanup(raw_text or \"\")\r\n+\r\n+                    processed_text = regex_text\r\n+                    try:\r\n+                        processed_text = self._app_ref.postprocessor.process(raw_text or \"\")\r\n+                    except RuntimeError as exc:\r\n+                        logger.error(\"LLM postprocess error: {}\", exc)\r\n+                        # Передаём текст ошибки наверх, чтобы UI показал его\r\n+                        self.error.emit(str(exc))\r\n+                    except Exception as exc:  # noqa: BLE001\r\n+                        logger.exception(\"Unexpected LLM postprocess error: {}\", exc)\r\n+                        self.error.emit(\"Ошибка LLM-постпроцессинга. См. логи.\")\r\n+\r\n+                    self.result_ready.emit(raw_text or \"\", processed_text or \"\")\r\n+                except RuntimeError as exc:\r\n+                    # Осмысленные ошибки от распознавания (например, Groq/GigaAM)\r\n+                    from loguru import logger as _logger\r\n+\r\n+                    _logger.error(\"Processing error: {}\", exc)\r\n+                    self.error.emit(str(exc))\r\n+                except Exception as exc:  # noqa: BLE001\r\n+                    from loguru import logger as _logger\r\n+\r\n+                    _logger.exception(\"Unexpected error during processing: {}\", exc)\r\n+                    self.error.emit(\"Неизвестная ошибка распознавания. См. логи.\")\r\n+                finally:\r\n+                    self.finished.emit()\r\n+\r\n+        self._ProcessingWorker = _ProcessingWorker  # type: ignore[attr-defined]\r\n+        self._processing_thread: Optional[QThread] = None\r\n+\r\n         # Hotkeys\r\n         self.hotkeys = HotKeyManager(\r\n             record_hotkey=self.settings.hotkeys.record,\r\n             cancel_hotkey=self.settings.hotkeys.cancel,\r\n@@ -165,10 +221,11 @@\n         self.window.set_state(\"recording\")\r\n \r\n         def on_finished(audio_data):\r\n             # Этот колбэк вызывается из потока рекордера.\r\n-            # Для MVP просто передаём данные в обработку синхронно.\r\n-            self._process_audio(audio_data)\r\n+            # Теперь только запускаем воркер в отдельном QThread,\r\n+            # а UI обновляем через сигналы.\r\n+            self._start_processing_worker(audio_data)\r\n \r\n         self.audio_recorder.start(on_finished=on_finished)\r\n \r\n     def stop_recording(self) -> None:\r\n@@ -184,95 +241,112 @@\n         self.audio_recorder.cancel()\r\n         self.window.set_state(\"idle\")\r\n \r\n     # ----------------------------------------------------------- Processing\r\n-    \r\n-    def _process_audio(self, audio_data) -> None:\r\n-        \"\"\"Synchronous processing for MVP; later can be moved to worker thread.\"\"\"\r\n+\r\n+    def _start_processing_worker(self, audio_data) -> None:\r\n+        \"\"\"\r\n+        Запуск тяжёлой обработки аудио (GigaAM/Groq + LLM) в отдельном QThread.\r\n+\r\n+        ВАЖНО: здесь мы только создаём поток и воркер, а все обновления UI\r\n+        делаем в слотах, которые вызываются уже в главном Qt-потоке.\r\n+        \"\"\"\r\n+        from PyQt6.QtCore import QThread\r\n         from loguru import logger\r\n         from pathlib import Path\r\n         from datetime import datetime\r\n-    \r\n-        try:\r\n-            self.window.set_state(\"processing\")\r\n-            # 1) сырой текст от Whisper\r\n-            raw_text = self.recognizer.transcribe(audio_data)\r\n-    \r\n-            # 2) regex-очистка (базовый препроцессинг всегда)\r\n-            from recognition.postprocessor import TextPostprocessor as TP  # локальный импорт для статик-метода\r\n-            regex_text = TP._simple_cleanup(raw_text or \"\")\r\n-    \r\n-            # 3) LLM-постпроцессинг (если включён в конфиге)\r\n-            processed_text = regex_text\r\n+\r\n+        # Если по какой-то причине предыдущий поток ещё жив — аккуратно его гасим.\r\n+        if self._processing_thread is not None:\r\n             try:\r\n-                processed_text = self.postprocessor.process(raw_text or \"\")\r\n-            except RuntimeError as exc:\r\n-                # осмысленные ошибки LLM\r\n-                logger.error(\"LLM postprocess error: {}\", exc)\r\n-                self.window.show_message(str(exc))\r\n-            except Exception as exc:  # noqa: BLE001\r\n-                logger.exception(\"Unexpected LLM postprocess error: {}\", exc)\r\n-                self.window.show_message(\"Ошибка LLM-постпроцессинга. См. логи.\")\r\n-    \r\n-            # 4) показать оба варианта в окне\r\n+                self._processing_thread.quit()\r\n+                self._processing_thread.wait(100)\r\n+            except Exception:\r\n+                logger.debug(\"Previous processing thread cleanup failed\", exc_info=True)\r\n+\r\n+        self.window.set_state(\"processing\")\r\n+\r\n+        thread = QThread(self.qt_app)\r\n+        worker = self._ProcessingWorker(self, audio_data)\r\n+        worker.moveToThread(thread)\r\n+\r\n+        def on_result(raw_text: str, processed_text: str) -> None:\r\n+            \"\"\"\r\n+            Этот слот вызывается в главном потоке Qt.\r\n+            Здесь можно безопасно трогать UI, буфер обмена и т.п.\r\n+            \"\"\"\r\n+            # 1) показать оба варианта в окне\r\n             try:\r\n-                # верхний блок — сырой текст от Whisper\r\n                 if hasattr(self.window, \"set_raw_text\"):\r\n                     self.window.set_raw_text(raw_text or \"\")\r\n                 else:\r\n-                    # fallback в старый result_label\r\n-                    self.window.result_label.setText(processed_text)\r\n-    \r\n-                # нижний блок — обработанный текст (regex/LLM)\r\n+                    self.window.result_label.setText(processed_text or \"\")\r\n+\r\n                 if hasattr(self.window, \"set_processed_text\"):\r\n-                    self.window.set_processed_text(processed_text)\r\n+                    self.window.set_processed_text(processed_text or \"\")\r\n             except Exception:\r\n                 logger.debug(\"window text update failed\", exc_info=True)\r\n-    \r\n-            # 5) положить ОБРАБОТАННЫЙ текст в буфер обмена\r\n-            self.clipboard.copy(processed_text)\r\n-    \r\n-            # авто-вставка текста через Ctrl+V (с ретраями внутри ClipboardManager)\r\n+\r\n+            # 2) положить ОБРАБОТАННЫЙ текст в буфер обмена\r\n+            self.clipboard.copy(processed_text or \"\")\r\n+\r\n+            # 3) авто-вставка текста через Ctrl+V (с ретраями внутри ClipboardManager)\r\n             self.clipboard.paste()\r\n-    \r\n-            # 6) сохранить распознавание в отдельный текстовый лог с ротацией по ~3 МБ\r\n+\r\n+            # 4) сохранить распознавание в отдельный текстовый лог с ротацией по ~3 МБ\r\n             try:\r\n                 base_dir = Path(__file__).resolve().parents[2]\r\n                 log_dir = base_dir / \"logs\"\r\n                 log_dir.mkdir(parents=True, exist_ok=True)\r\n                 transcript_path = log_dir / \"transcripts.log\"\r\n-    \r\n-                # простая ротация: если файл больше 3 МБ — переименовать в transcripts_YYYYmmdd_HHMMSS.log\r\n+\r\n                 max_size_bytes = 3 * 1024 * 1024\r\n                 if transcript_path.exists() and transcript_path.stat().st_size >= max_size_bytes:\r\n                     ts = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\r\n                     rotated = log_dir / f\"transcripts_{ts}.log\"\r\n                     transcript_path.rename(rotated)\r\n-    \r\n-                # формат записи: время, сырой текст, обработанный текст\r\n+\r\n                 with transcript_path.open(\"a\", encoding=\"utf-8\") as f:\r\n                     f.write(\r\n                         f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]\\\\n\"\r\n                         f\"RAW: { (raw_text or '').strip() }\\\\n\"\r\n                         f\"PROCESSED: { (processed_text or '').strip() }\\\\n\"\r\n                         \"----------------------------------------\\\\n\"\r\n                     )\r\n             except Exception as exc:  # noqa: BLE001\r\n-                # не ломаем основной флоу, если что-то пошло не так с логом\r\n                 logger.exception(\"Failed to append transcript log: {}\", exc)\r\n-    \r\n+\r\n             self.window.set_state(\"ready\")\r\n-        except RuntimeError as exc:\r\n-            # Осмысленные ошибки от распознавания (например, Groq API)\r\n-            logger.error(\"Processing error: {}\", exc)\r\n+\r\n+        def on_error(message: str) -> None:\r\n+            \"\"\"\r\n+            Слот для ошибок распознавания/LLM.\r\n+            \"\"\"\r\n+            logger = __import__(\"loguru\").logger  # избежать замыкания logger сверху\r\n+            logger.error(\"Processing error (worker): {}\", message)\r\n             self.window.set_state(\"error\")\r\n-            # Показываем пользователю человекочитаемое сообщение\r\n-            self.window.show_message(str(exc))\r\n-        except Exception as exc:  # noqa: BLE001\r\n-            logger.exception(\"Unexpected error during processing: {}\", exc)\r\n-            self.window.set_state(\"error\")\r\n-            self.window.show_message(\"Неизвестная ошибка распознавания. См. логи.\")\r\n+            self.window.show_message(message)\r\n \r\n+        def on_finished() -> None:\r\n+            \"\"\"\r\n+            Слот завершения работы воркера: чистим поток.\r\n+            \"\"\"\r\n+            thread.quit()\r\n+            thread.wait()\r\n+            self._processing_thread = None\r\n+            # Сбрасываем флаг записи, если ещё не сброшен\r\n+            self._is_recording = False\r\n+\r\n+        # wiring сигналов\r\n+        thread.started.connect(worker.run)          # type: ignore[arg-type]\r\n+        worker.result_ready.connect(on_result)      # type: ignore[arg-type]\r\n+        worker.error.connect(on_error)              # type: ignore[arg-type]\r\n+        worker.finished.connect(on_finished)        # type: ignore[arg-type]\r\n+        worker.finished.connect(worker.deleteLater) # type: ignore[arg-type]\r\n+\r\n+        self._processing_thread = thread\r\n+        thread.start()\r\n+\r\n     # -------------------------------------------------------------- Debug\r\n \r\n     def toggle_debug_mode(self) -> None:\r\n         # Placeholder: will reconfigure logging level later\r\n"
                },
                {
                    "date": 1764462394215,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -246,10 +246,13 @@\n     def _start_processing_worker(self, audio_data) -> None:\r\n         \"\"\"\r\n         Запуск тяжёлой обработки аудио (GigaAM/Groq + LLM) в отдельном QThread.\r\n \r\n-        ВАЖНО: здесь мы только создаём поток и воркер, а все обновления UI\r\n-        делаем в слотах, которые вызываются уже в главном Qt-потоке.\r\n+        ВАЖНО:\r\n+        - QThread создаём БЕЗ родителя (никаких QObject в чужом потоке),\r\n+        - воркер не трогает UI,\r\n+        - все обновления UI делаем только в слотах, которые Qt вызывает\r\n+          в главном потоке.\r\n         \"\"\"\r\n         from PyQt6.QtCore import QThread\r\n         from loguru import logger\r\n         from pathlib import Path\r\n@@ -262,11 +265,13 @@\n                 self._processing_thread.wait(100)\r\n             except Exception:\r\n                 logger.debug(\"Previous processing thread cleanup failed\", exc_info=True)\r\n \r\n+        # Состояние UI меняем в главном потоке\r\n         self.window.set_state(\"processing\")\r\n \r\n-        thread = QThread(self.qt_app)\r\n+        # ВАЖНО: QThread без родителя, чтобы не было \"parent is QApplication in different thread\"\r\n+        thread = QThread()\r\n         worker = self._ProcessingWorker(self, audio_data)\r\n         worker.moveToThread(thread)\r\n \r\n         def on_result(raw_text: str, processed_text: str) -> None:\r\n"
                },
                {
                    "date": 1764462623945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,64 +73,8 @@\n \r\n         # State\r\n         self._is_recording: bool = False\r\n \r\n-        # Worker thread for heavy audio processing (GigaAM / Groq / LLM)\r\n-        from PyQt6.QtCore import QObject, QThread, pyqtSignal\r\n-\r\n-        class _ProcessingWorker(QObject):\r\n-            finished = pyqtSignal()\r\n-            error = pyqtSignal(str)\r\n-            result_ready = pyqtSignal(str, str)  # raw_text, processed_text\r\n-\r\n-            def __init__(self, app_ref: \"App\", audio_data) -> None:\r\n-                super().__init__()\r\n-                self._app_ref = app_ref\r\n-                self._audio_data = audio_data\r\n-\r\n-            def run(self) -> None:\r\n-                \"\"\"\r\n-                Выполняется в отдельном потоке:\r\n-                - распознавание (Groq/GigaAM)\r\n-                - regex + LLM постобработка\r\n-                Никаких Qt-объектов/виджетов здесь не трогаем.\r\n-                \"\"\"\r\n-                from loguru import logger\r\n-                from recognition.postprocessor import TextPostprocessor as TP\r\n-\r\n-                try:\r\n-                    raw_text = self._app_ref.recognizer.transcribe(self._audio_data)\r\n-                    regex_text = TP._simple_cleanup(raw_text or \"\")\r\n-\r\n-                    processed_text = regex_text\r\n-                    try:\r\n-                        processed_text = self._app_ref.postprocessor.process(raw_text or \"\")\r\n-                    except RuntimeError as exc:\r\n-                        logger.error(\"LLM postprocess error: {}\", exc)\r\n-                        # Передаём текст ошибки наверх, чтобы UI показал его\r\n-                        self.error.emit(str(exc))\r\n-                    except Exception as exc:  # noqa: BLE001\r\n-                        logger.exception(\"Unexpected LLM postprocess error: {}\", exc)\r\n-                        self.error.emit(\"Ошибка LLM-постпроцессинга. См. логи.\")\r\n-\r\n-                    self.result_ready.emit(raw_text or \"\", processed_text or \"\")\r\n-                except RuntimeError as exc:\r\n-                    # Осмысленные ошибки от распознавания (например, Groq/GigaAM)\r\n-                    from loguru import logger as _logger\r\n-\r\n-                    _logger.error(\"Processing error: {}\", exc)\r\n-                    self.error.emit(str(exc))\r\n-                except Exception as exc:  # noqa: BLE001\r\n-                    from loguru import logger as _logger\r\n-\r\n-                    _logger.exception(\"Unexpected error during processing: {}\", exc)\r\n-                    self.error.emit(\"Неизвестная ошибка распознавания. См. логи.\")\r\n-                finally:\r\n-                    self.finished.emit()\r\n-\r\n-        self._ProcessingWorker = _ProcessingWorker  # type: ignore[attr-defined]\r\n-        self._processing_thread: Optional[QThread] = None\r\n-\r\n         # Hotkeys\r\n         self.hotkeys = HotKeyManager(\r\n             record_hotkey=self.settings.hotkeys.record,\r\n             cancel_hotkey=self.settings.hotkeys.cancel,\r\n@@ -221,11 +165,10 @@\n         self.window.set_state(\"recording\")\r\n \r\n         def on_finished(audio_data):\r\n             # Этот колбэк вызывается из потока рекордера.\r\n-            # Теперь только запускаем воркер в отдельном QThread,\r\n-            # а UI обновляем через сигналы.\r\n-            self._start_processing_worker(audio_data)\r\n+            # Возвращаемся к синхронной обработке, как в рабочем варианте.\r\n+            self._process_audio(audio_data)\r\n \r\n         self.audio_recorder.start(on_finished=on_finished)\r\n \r\n     def stop_recording(self) -> None:\r\n@@ -242,45 +185,36 @@\n         self.window.set_state(\"idle\")\r\n \r\n     # ----------------------------------------------------------- Processing\r\n \r\n-    def _start_processing_worker(self, audio_data) -> None:\r\n-        \"\"\"\r\n-        Запуск тяжёлой обработки аудио (GigaAM/Groq + LLM) в отдельном QThread.\r\n-\r\n-        ВАЖНО:\r\n-        - QThread создаём БЕЗ родителя (никаких QObject в чужом потоке),\r\n-        - воркер не трогает UI,\r\n-        - все обновления UI делаем только в слотах, которые Qt вызывает\r\n-          в главном потоке.\r\n-        \"\"\"\r\n-        from PyQt6.QtCore import QThread\r\n+    def _process_audio(self, audio_data) -> None:\r\n+        \"\"\"Синхронная обработка аудио (как в рабочем MVP).\"\"\"\r\n         from loguru import logger\r\n         from pathlib import Path\r\n         from datetime import datetime\r\n+        from recognition.postprocessor import TextPostprocessor as TP  # для _simple_cleanup\r\n \r\n-        # Если по какой-то причине предыдущий поток ещё жив — аккуратно его гасим.\r\n-        if self._processing_thread is not None:\r\n-            try:\r\n-                self._processing_thread.quit()\r\n-                self._processing_thread.wait(100)\r\n-            except Exception:\r\n-                logger.debug(\"Previous processing thread cleanup failed\", exc_info=True)\r\n+        try:\r\n+            self.window.set_state(\"processing\")\r\n+            # 1) сырой текст от распознавателя (Groq / GigaAM)\r\n+            raw_text = self.recognizer.transcribe(audio_data)\r\n \r\n-        # Состояние UI меняем в главном потоке\r\n-        self.window.set_state(\"processing\")\r\n+            # 2) regex-очистка (базовый препроцессинг всегда)\r\n+            regex_text = TP._simple_cleanup(raw_text or \"\")\r\n \r\n-        # ВАЖНО: QThread без родителя, чтобы не было \"parent is QApplication in different thread\"\r\n-        thread = QThread()\r\n-        worker = self._ProcessingWorker(self, audio_data)\r\n-        worker.moveToThread(thread)\r\n+            # 3) LLM-постпроцессинг (если включён в конфиге)\r\n+            processed_text = regex_text\r\n+            try:\r\n+                processed_text = self.postprocessor.process(raw_text or \"\")\r\n+            except RuntimeError as exc:\r\n+                # осмысленные ошибки LLM\r\n+                logger.error(\"LLM postprocess error: {}\", exc)\r\n+                self.window.show_message(str(exc))\r\n+            except Exception as exc:  # noqa: BLE001\r\n+                logger.exception(\"Unexpected LLM postprocess error: {}\", exc)\r\n+                self.window.show_message(\"Ошибка LLM-постпроцессинга. См. логи.\")\r\n \r\n-        def on_result(raw_text: str, processed_text: str) -> None:\r\n-            \"\"\"\r\n-            Этот слот вызывается в главном потоке Qt.\r\n-            Здесь можно безопасно трогать UI, буфер обмена и т.п.\r\n-            \"\"\"\r\n-            # 1) показать оба варианта в окне\r\n+            # 4) показать оба варианта в окне\r\n             try:\r\n                 if hasattr(self.window, \"set_raw_text\"):\r\n                     self.window.set_raw_text(raw_text or \"\")\r\n                 else:\r\n@@ -290,15 +224,15 @@\n                     self.window.set_processed_text(processed_text or \"\")\r\n             except Exception:\r\n                 logger.debug(\"window text update failed\", exc_info=True)\r\n \r\n-            # 2) положить ОБРАБОТАННЫЙ текст в буфер обмена\r\n+            # 5) положить ОБРАБОТАННЫЙ текст в буфер обмена\r\n             self.clipboard.copy(processed_text or \"\")\r\n \r\n-            # 3) авто-вставка текста через Ctrl+V (с ретраями внутри ClipboardManager)\r\n+            # 6) авто-вставка текста через Ctrl+V (с ретраями внутри ClipboardManager)\r\n             self.clipboard.paste()\r\n \r\n-            # 4) сохранить распознавание в отдельный текстовый лог с ротацией по ~3 МБ\r\n+            # 7) сохранить распознавание в отдельный текстовый лог с ротацией по ~3 МБ\r\n             try:\r\n                 base_dir = Path(__file__).resolve().parents[2]\r\n                 log_dir = base_dir / \"logs\"\r\n                 log_dir.mkdir(parents=True, exist_ok=True)\r\n@@ -320,38 +254,18 @@\n             except Exception as exc:  # noqa: BLE001\r\n                 logger.exception(\"Failed to append transcript log: {}\", exc)\r\n \r\n             self.window.set_state(\"ready\")\r\n-\r\n-        def on_error(message: str) -> None:\r\n-            \"\"\"\r\n-            Слот для ошибок распознавания/LLM.\r\n-            \"\"\"\r\n-            logger = __import__(\"loguru\").logger  # избежать замыкания logger сверху\r\n-            logger.error(\"Processing error (worker): {}\", message)\r\n+        except RuntimeError as exc:\r\n+            # Осмысленные ошибки от распознавания (например, Groq API)\r\n+            logger.error(\"Processing error: {}\", exc)\r\n             self.window.set_state(\"error\")\r\n-            self.window.show_message(message)\r\n+            self.window.show_message(str(exc))\r\n+        except Exception as exc:  # noqa: BLE001\r\n+            logger.exception(\"Unexpected error during processing: {}\", exc)\r\n+            self.window.set_state(\"error\")\r\n+            self.window.show_message(\"Неизвестная ошибка распознавания. См. логи.\")\r\n \r\n-        def on_finished() -> None:\r\n-            \"\"\"\r\n-            Слот завершения работы воркера: чистим поток.\r\n-            \"\"\"\r\n-            thread.quit()\r\n-            thread.wait()\r\n-            self._processing_thread = None\r\n-            # Сбрасываем флаг записи, если ещё не сброшен\r\n-            self._is_recording = False\r\n-\r\n-        # wiring сигналов\r\n-        thread.started.connect(worker.run)          # type: ignore[arg-type]\r\n-        worker.result_ready.connect(on_result)      # type: ignore[arg-type]\r\n-        worker.error.connect(on_error)              # type: ignore[arg-type]\r\n-        worker.finished.connect(on_finished)        # type: ignore[arg-type]\r\n-        worker.finished.connect(worker.deleteLater) # type: ignore[arg-type]\r\n-\r\n-        self._processing_thread = thread\r\n-        thread.start()\r\n-\r\n     # -------------------------------------------------------------- Debug\r\n \r\n     def toggle_debug_mode(self) -> None:\r\n         # Placeholder: will reconfigure logging level later\r\n"
                },
                {
                    "date": 1764463456430,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,32 +186,82 @@\n \r\n     # ----------------------------------------------------------- Processing\r\n \r\n     def _process_audio(self, audio_data) -> None:\r\n-        \"\"\"Синхронная обработка аудио (как в рабочем MVP).\"\"\"\r\n+        \"\"\"\r\n+        Синхронная обработка аудио с каскадом backend'ов:\r\n+        1) основной backend из настроек (groq / openai / local),\r\n+        2) при ошибке — fallback на остальные по приоритету.\r\n+        \"\"\"\r\n         from loguru import logger\r\n         from pathlib import Path\r\n         from datetime import datetime\r\n         from recognition.postprocessor import TextPostprocessor as TP  # для _simple_cleanup\r\n+        from recognition import create_recognizer  # каскадное создание по backend'у\r\n \r\n+        self.window.set_state(\"processing\")\r\n+\r\n+        # Собираем приоритетный список backend'ов:\r\n+        # сначала выбранный пользователем, затем остальные.\r\n+        primary = (self.settings.recognition.backend or \"groq\").lower()\r\n+        all_backends = [\"groq\", \"openai\", \"local\"]\r\n+        cascade = [b for b in [primary] + all_backends if b in all_backends]\r\n+        # Убираем дубликаты, сохраняя порядок\r\n+        seen = set()\r\n+        ordered_backends = []\r\n+        for b in cascade:\r\n+            if b not in seen:\r\n+                seen.add(b)\r\n+                ordered_backends.append(b)\r\n+\r\n+        last_error: str | None = None\r\n+        raw_text: str | None = None\r\n+\r\n+        for backend in ordered_backends:\r\n+            try:\r\n+                logger.info(\"Trying recognition backend: {}\", backend)\r\n+                # Временно подменяем backend в настройках для фабрики\r\n+                original_backend = self.settings.recognition.backend\r\n+                self.settings.recognition.backend = backend\r\n+                recognizer = create_recognizer(self.settings.recognition)\r\n+                # ВАЖНО: возвращаем исходный backend в настройках\r\n+                self.settings.recognition.backend = original_backend\r\n+\r\n+                raw_text = recognizer.transcribe(audio_data)\r\n+                logger.info(\"Recognition succeeded with backend: {}\", backend)\r\n+                break\r\n+            except RuntimeError as exc:\r\n+                # Осмысленная ошибка — логируем и пробуем следующий backend\r\n+                logger.error(\"Recognition error on backend {}: {}\", backend, exc)\r\n+                last_error = str(exc)\r\n+                continue\r\n+            except Exception as exc:  # noqa: BLE001\r\n+                logger.exception(\"Unexpected recognition error on backend {}: {}\", backend, exc)\r\n+                last_error = f\"Неизвестная ошибка backend '{backend}'. См. логи.\"\r\n+                continue\r\n+\r\n+        if raw_text is None:\r\n+            # Все backend'ы упали — показываем последнюю ошибку\r\n+            msg = last_error or \"Не удалось распознать аудио ни одним backend'ом.\"\r\n+            self.window.set_state(\"error\")\r\n+            self.window.show_message(msg)\r\n+            return\r\n+\r\n+        from loguru import logger as _logger\r\n+\r\n         try:\r\n-            self.window.set_state(\"processing\")\r\n-            # 1) сырой текст от распознавателя (Groq / GigaAM)\r\n-            raw_text = self.recognizer.transcribe(audio_data)\r\n-\r\n             # 2) regex-очистка (базовый препроцессинг всегда)\r\n             regex_text = TP._simple_cleanup(raw_text or \"\")\r\n \r\n             # 3) LLM-постпроцессинг (если включён в конфиге)\r\n             processed_text = regex_text\r\n             try:\r\n                 processed_text = self.postprocessor.process(raw_text or \"\")\r\n             except RuntimeError as exc:\r\n-                # осмысленные ошибки LLM\r\n-                logger.error(\"LLM postprocess error: {}\", exc)\r\n+                _logger.error(\"LLM postprocess error: {}\", exc)\r\n                 self.window.show_message(str(exc))\r\n             except Exception as exc:  # noqa: BLE001\r\n-                logger.exception(\"Unexpected LLM postprocess error: {}\", exc)\r\n+                _logger.exception(\"Unexpected LLM postprocess error: {}\", exc)\r\n                 self.window.show_message(\"Ошибка LLM-постпроцессинга. См. логи.\")\r\n \r\n             # 4) показать оба варианта в окне\r\n             try:\r\n@@ -222,9 +272,9 @@\n \r\n                 if hasattr(self.window, \"set_processed_text\"):\r\n                     self.window.set_processed_text(processed_text or \"\")\r\n             except Exception:\r\n-                logger.debug(\"window text update failed\", exc_info=True)\r\n+                _logger.debug(\"window text update failed\", exc_info=True)\r\n \r\n             # 5) положить ОБРАБОТАННЫЙ текст в буфер обмена\r\n             self.clipboard.copy(processed_text or \"\")\r\n \r\n@@ -251,20 +301,15 @@\n                         f\"PROCESSED: { (processed_text or '').strip() }\\\\n\"\r\n                         \"----------------------------------------\\\\n\"\r\n                     )\r\n             except Exception as exc:  # noqa: BLE001\r\n-                logger.exception(\"Failed to append transcript log: {}\", exc)\r\n+                _logger.exception(\"Failed to append transcript log: {}\", exc)\r\n \r\n             self.window.set_state(\"ready\")\r\n-        except RuntimeError as exc:\r\n-            # Осмысленные ошибки от распознавания (например, Groq API)\r\n-            logger.error(\"Processing error: {}\", exc)\r\n-            self.window.set_state(\"error\")\r\n-            self.window.show_message(str(exc))\r\n         except Exception as exc:  # noqa: BLE001\r\n-            logger.exception(\"Unexpected error during processing: {}\", exc)\r\n+            _logger.exception(\"Unexpected error during post-processing: {}\", exc)\r\n             self.window.set_state(\"error\")\r\n-            self.window.show_message(\"Неизвестная ошибка распознавания. См. логи.\")\r\n+            self.window.show_message(\"Неизвестная ошибка постобработки. См. логи.\")\r\n \r\n     # -------------------------------------------------------------- Debug\r\n \r\n     def toggle_debug_mode(self) -> None:\r\n"
                },
                {
                    "date": 1764468303756,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,9 +88,8 @@\n         )\r\n \r\n         # Wire UI signals\r\n         self.window.settings_requested.connect(self.open_settings_dialog)\r\n-        self.window.settings_save_requested.connect(self._on_settings_save_requested)\r\n         self.window.exit_requested.connect(self.quit)\r\n         self.tray.show_window_requested.connect(self.show_window)\r\n         self.tray.settings_requested.connect(self.open_settings_dialog)\r\n         self.tray.toggle_debug_requested.connect(self.toggle_debug_mode)\r\n@@ -116,47 +115,64 @@\n         self.show_window()\r\n \r\n     def open_settings_dialog(self) -> None:\r\n         \"\"\"\r\n-        Открыть панель настроек внутри основного окна.\r\n+        Открыть диалог настроек (SettingsDialog) и применить изменения.\r\n+        \"\"\"\r\n+        from ui.settings_dialog import SettingsDialog  # локальный импорт, чтобы избежать циклов\r\n \r\n-        ВАЖНО: все значения берём/кладём только в config.yaml через AppSettings.\r\n-        \"\"\"\r\n-        # показать окно\r\n+        # показать основное окно, чтобы диалог был поверх\r\n         self.show_window()\r\n \r\n-        # заполнить UI текущими значениями из self.settings\r\n-        rec = self.settings.recognition\r\n-        post = self.settings.postprocess\r\n+        dlg = SettingsDialog(self.settings, parent=self.window)\r\n+        if dlg.exec() != dlg.DialogCode.Accepted:\r\n+            return\r\n \r\n-        # backend\r\n-        backend_value = (rec.backend or \"groq\").lower()\r\n-        idx = self.window.settings_backend_combo.findData(backend_value)\r\n-        if idx >= 0:\r\n-            self.window.settings_backend_combo.setCurrentIndex(idx)\r\n+        new_settings = dlg.get_result()\r\n+        if new_settings is None:\r\n+            return\r\n \r\n-        # API keys / base URL\r\n-        self.window.settings_groq_key.setText(rec.groq.api_key or \"\")\r\n-        self.window.settings_openai_key.setText(rec.openai.api_key or \"\")\r\n-        self.window.settings_openai_url.setText(rec.openai.base_url or \"\")\r\n+        # обновляем настройки в памяти\r\n+        self.settings = new_settings\r\n \r\n-        # postprocess\r\n-        self.window.postprocess_enabled_checkbox.setChecked(post.enabled)\r\n+        # сохраняем в config.yaml\r\n+        AppSettings.save_default(self.settings)\r\n \r\n-        # Если в конфиге пустые строки, подставляем дефолты,\r\n-        # чтобы поля в UI были уже заполнены при первом открытии.\r\n-        # По твоему запросу:\r\n-        #   - Groq postprocess model:   mixtral-8x7b-32768\r\n-        #   - OpenAI postprocess model: gpt-5.1\r\n-        groq_model = (post.groq.model or \"\").strip() or \"mixtral-8x7b-32768\"\r\n-        openai_model = (post.openai.model or \"\").strip() or \"gpt-5.1\"\r\n+        # пересоздаём recognizer и postprocessor с учётом новых настроек\r\n+        self.recognizer = create_recognizer(self.settings.recognition)\r\n \r\n-        self.window.postprocess_groq_model.setText(groq_model)\r\n-        self.window.postprocess_openai_model.setText(openai_model)\r\n+        post_cfg = self.settings.postprocess\r\n+        rec_cfg = self.settings.recognition\r\n \r\n-        # переключаем окно в режим настроек\r\n-        self.window._enter_settings_mode()\r\n+        if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n+            setattr(post_cfg.groq, \"api_key\", rec_cfg.groq.api_key)\r\n+            if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n+                setattr(post_cfg.groq, \"model_process\", rec_cfg.groq.model_process)\r\n \r\n+        if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n+            setattr(post_cfg.openai, \"api_key\", rec_cfg.openai.api_key)\r\n+            if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n+                setattr(post_cfg.openai, \"model_process\", rec_cfg.openai.model_process)\r\n+\r\n+        self.postprocessor = TextPostprocessor(post_cfg)\r\n+\r\n+        # если теперь ключи заданы — убрать предупреждающую надпись\r\n+        backend = (self.settings.recognition.backend or \"groq\").lower()\r\n+        has_key = False\r\n+        if backend == \"groq\" and (self.settings.recognition.groq.api_key or \"\").strip():\r\n+            has_key = True\r\n+        elif backend == \"openai\" and (self.settings.recognition.openai.api_key or \"\").strip():\r\n+            has_key = True\r\n+\r\n+        if has_key:\r\n+            if hasattr(self.window, \"set_raw_text\"):\r\n+                self.window.set_raw_text(\"\")\r\n+            if hasattr(self.window, \"set_processed_text\"):\r\n+                self.window.set_processed_text(\"\")\r\n+            self.window.result_label.setText(\"\")\r\n+\r\n+        self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n+\r\n     # ----------------------------------------------------------------- Hotkeys\r\n \r\n     def start_recording(self) -> None:\r\n         if self._is_recording:\r\n@@ -316,82 +332,12 @@\n         # Placeholder: will reconfigure logging level later\r\n         self.window.show_message(\"Toggle debug (not fully implemented yet).\")\r\n \r\n     # ----------------------------------------------------------- Settings save\r\n-\r\n+    # Встроенный обработчик сохранения панели настроек больше не нужен:\r\n+    # всё делает open_settings_dialog() через SettingsDialog.\r\n     def _on_settings_save_requested(self) -> None:\r\n-        \"\"\"\r\n-        Пользователь нажал «Сохранить» в панели настроек.\r\n-        Читаем значения из UI, обновляем self.settings, сохраняем в config.yaml\r\n-        и пересоздаём recognizer/postprocessor.\r\n-        \"\"\"\r\n-        from config.settings import AppSettings  # локальный импорт, чтобы избежать циклов\r\n-    \r\n-        rec = self.settings.recognition\r\n-        post = self.settings.postprocess\r\n-    \r\n-        # 1) backend\r\n-        backend_data = self.window.settings_backend_combo.currentData()\r\n-        if backend_data in (\"groq\", \"openai\", \"local\"):\r\n-            rec.backend = backend_data\r\n-    \r\n-        # 2) API keys / base URL\r\n-        rec.groq.api_key = self.window.settings_groq_key.text().strip() or rec.groq.api_key\r\n-        rec.openai.api_key = self.window.settings_openai_key.text().strip() or rec.openai.api_key\r\n-        base_url = self.window.settings_openai_url.text().strip()\r\n-        if base_url:\r\n-            rec.openai.base_url = base_url\r\n-    \r\n-        # 3) postprocess\r\n-        post.enabled = self.window.postprocess_enabled_checkbox.isChecked()\r\n-    \r\n-        # модели LLM: пишем в recognition.*.model_process и синхронизируем postprocess.*.model\r\n-        groq_model_proc = self.window.postprocess_groq_model.text().strip()\r\n-        if groq_model_proc:\r\n-            rec.groq.model_process = groq_model_proc\r\n-            post.groq.model = groq_model_proc\r\n-    \r\n-        openai_model_proc = self.window.postprocess_openai_model.text().strip()\r\n-        if openai_model_proc:\r\n-            rec.openai.model_process = openai_model_proc\r\n-            post.openai.model = openai_model_proc\r\n-    \r\n-        # 4) сохранить всё в config.yaml\r\n-        AppSettings.save_default(self.settings)\r\n-    \r\n-        # 5) пересоздать recognizer и postprocessor\r\n-        self.recognizer = create_recognizer(self.settings.recognition)\r\n-    \r\n-        post_cfg = self.settings.postprocess\r\n-        if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n-            setattr(post_cfg.groq, \"api_key\", rec.groq.api_key)\r\n-            if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n-                setattr(post_cfg.groq, \"model_process\", rec.groq.model_process)\r\n-        if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n-            setattr(post_cfg.openai, \"api_key\", rec.openai.api_key)\r\n-            if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n-                setattr(post_cfg.openai, \"model_process\", rec.openai.model_process)\r\n-    \r\n-        self.postprocessor = TextPostprocessor(post_cfg)\r\n-    \r\n-        # 6) если теперь ключи заданы — убрать предупреждающую надпись\r\n-        backend = (self.settings.recognition.backend or \"groq\").lower()\r\n-        has_key = False\r\n-        if backend == \"groq\" and (self.settings.recognition.groq.api_key or \"\").strip():\r\n-            has_key = True\r\n-        elif backend == \"openai\" and (self.settings.recognition.openai.api_key or \"\").strip():\r\n-            has_key = True\r\n-    \r\n-        if has_key:\r\n-            # очищаем все текстовые блоки, чтобы не висело старое предупреждение\r\n-            if hasattr(self.window, \"set_raw_text\"):\r\n-                self.window.set_raw_text(\"\")\r\n-            if hasattr(self.window, \"set_processed_text\"):\r\n-                self.window.set_processed_text(\"\")\r\n-            self.window.result_label.setText(\"\")\r\n-    \r\n-        # 7) показать уведомление\r\n-        self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n+        return\r\n \r\n     # -------------------------------------------------------------- Lifecycle\r\n \r\n     def quit(self) -> None:\r\n"
                },
                {
                    "date": 1764469329776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,8 +51,9 @@\n             if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n                 setattr(post_cfg.groq, \"model_process\", rec_cfg.groq.model_process)\r\n \r\n         if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n+            # ключ для LLM всегда берём из поля OpenAI API key (recognition.openai.api_key)\r\n             setattr(post_cfg.openai, \"api_key\", rec_cfg.openai.api_key)\r\n             if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n                 setattr(post_cfg.openai, \"model_process\", rec_cfg.openai.model_process)\r\n \r\n"
                }
            ],
            "date": 1764291847746,
            "name": "Commit-0",
            "content": "import sys\r\nfrom typing import Optional\r\n\r\nfrom PyQt6.QtWidgets import QApplication\r\n\r\nfrom config.settings import AppSettings\r\nfrom ui.floating_window import FloatingWindow\r\nfrom ui.system_tray import SystemTrayIcon\r\nfrom hotkey.hotkey_manager import HotKeyManager\r\nfrom audio.recorder import AudioRecorder\r\nfrom clipboard.clipboard_manager import ClipboardManager\r\nfrom recognition import create_recognizer\r\nfrom recognition.postprocessor import TextPostprocessor\r\nfrom utils.logger import setup_logging\r\n\r\n\r\nclass App:\r\n    \"\"\"\r\n    Main application class: wires UI, hotkeys, audio recorder, recognizer and clipboard.\r\n\r\n    MVP workflow:\r\n        global hotkey (record) down   -> start_recording()\r\n        global hotkey (record) up     -> stop_recording()\r\n        audio -> recognizer (Groq) -> postprocess -> clipboard.copy + paste\r\n    \"\"\"\r\n\r\n    def __init__(self) -> None:\r\n        self.qt_app = QApplication(sys.argv)\r\n\r\n        # Load settings and logging\r\n        self.settings = AppSettings.load_default()\r\n        setup_logging(self.settings.logging)\r\n\r\n        # Core components\r\n        self.window = FloatingWindow(self.settings.ui)\r\n        self.tray = SystemTrayIcon(self.window, self.settings.app)\r\n        self.clipboard = ClipboardManager()\r\n        self.audio_recorder = AudioRecorder(self.settings.audio)\r\n        self.recognizer = create_recognizer(self.settings.recognition)\r\n        self.postprocessor = TextPostprocessor(self.settings.postprocess)\r\n\r\n        # State\r\n        self._is_recording: bool = False\r\n\r\n        # Hotkeys\r\n        self.hotkeys = HotKeyManager(\r\n            record_hotkey=self.settings.hotkeys.record,\r\n            cancel_hotkey=self.settings.hotkeys.cancel,\r\n            toggle_window_hotkey=self.settings.hotkeys.toggle_window,\r\n            toggle_debug_hotkey=self.settings.hotkeys.toggle_debug,\r\n            on_record_press=self.start_recording,\r\n            on_record_release=self.stop_recording,\r\n            on_cancel=self.cancel_recording,\r\n            on_toggle_window=self.toggle_window_visibility,\r\n            on_toggle_debug=self.toggle_debug_mode,\r\n        )\r\n\r\n        # Wire UI signals\r\n        self.window.settings_requested.connect(self.open_settings_dialog)\r\n        self.window.exit_requested.connect(self.quit)\r\n        self.tray.show_window_requested.connect(self.show_window)\r\n        self.tray.settings_requested.connect(self.open_settings_dialog)\r\n        self.tray.toggle_debug_requested.connect(self.toggle_debug_mode)\r\n        self.tray.exit_requested.connect(self.quit)\r\n\r\n    # --------------------------------------------------------------------- UI\r\n\r\n    def show_window(self) -> None:\r\n        self.window.show()\r\n        self.window.raise_()\r\n        self.window.activateWindow()\r\n\r\n    def toggle_window_visibility(self) -> None:\r\n        if self.window.isVisible():\r\n            self.window.hide()\r\n        else:\r\n            self.show_window()\r\n\r\n    def open_settings_dialog(self) -> None:\r\n        # Placeholder: real implementation will open SettingsDialog\r\n        self.window.show_message(\"Settings dialog is not implemented yet (MVP skeleton).\")\r\n\r\n    # ----------------------------------------------------------------- Hotkeys\r\n\r\n    def start_recording(self) -> None:\r\n        if self._is_recording:\r\n            return\r\n        self._is_recording = True\r\n        self.window.set_state(\"recording\")\r\n\r\n        def on_finished(audio_data):\r\n            # Этот колбэк вызывается из потока рекордера.\r\n            # Для MVP просто передаём данные в обработку синхронно.\r\n            self._process_audio(audio_data)\r\n\r\n        self.audio_recorder.start(on_finished=on_finished)\r\n\r\n    def stop_recording(self) -> None:\r\n        if not self._is_recording:\r\n            return\r\n        self._is_recording = False\r\n        self.audio_recorder.stop()\r\n\r\n    def cancel_recording(self) -> None:\r\n        if not self._is_recording:\r\n            return\r\n        self._is_recording = False\r\n        self.audio_recorder.cancel()\r\n        self.window.set_state(\"idle\")\r\n\r\n    # ----------------------------------------------------------- Processing\r\n\r\n    def _process_audio(self, audio_data) -> None:\r\n        \"\"\"Synchronous processing for MVP; later can be moved to worker thread.\"\"\"\r\n        try:\r\n            self.window.set_state(\"processing\")\r\n            text = self.recognizer.transcribe(audio_data)\r\n            text = self.postprocessor.process(text)\r\n            self.clipboard.copy(text)\r\n            self.clipboard.paste()\r\n            self.window.set_state(\"ready\")\r\n        except Exception as exc:  # noqa: BLE001\r\n            from loguru import logger\r\n\r\n            logger.exception(\"Error during processing: {}\", exc)\r\n            self.window.set_state(\"error\")\r\n            self.window.show_message(\"Error during recognition. See logs.\")\r\n\r\n    # -------------------------------------------------------------- Debug\r\n\r\n    def toggle_debug_mode(self) -> None:\r\n        # Placeholder: will reconfigure logging level later\r\n        self.window.show_message(\"Toggle debug (not fully implemented yet).\")\r\n\r\n    # -------------------------------------------------------------- Lifecycle\r\n\r\n    def quit(self) -> None:\r\n        self.hotkeys.stop()\r\n        self.qt_app.quit()\r\n\r\n    def run(self) -> None:\r\n        self.hotkeys.start()\r\n        self.show_window()\r\n        sys.exit(self.qt_app.exec())\r\n\r\n\r\ndef main() -> None:\r\n    app = App()\r\n    app.run()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()"
        }
    ]
}