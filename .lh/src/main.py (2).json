{
    "sourceFile": "src/main.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764628138336,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764628138336,
            "name": "Commit-0",
            "content": "import sys\r\nfrom pathlib import Path\r\nfrom typing import Optional\r\n\r\nfrom PyQt6.QtWidgets import QApplication\r\n\r\nfrom config.settings import AppSettings\r\nfrom ui.floating_window import FloatingWindow\r\nfrom ui.system_tray import SystemTrayIcon\r\nfrom hotkey.hotkey_manager import HotKeyManager\r\nfrom audio.recorder import AudioRecorder\r\nfrom clipboard.clipboard_manager import ClipboardManager\r\nfrom recognition import create_recognizer\r\nfrom recognition.postprocessor import TextPostprocessor\r\nfrom utils.logger import setup_logging\r\n\r\n\r\nclass App:\r\n    \"\"\"\r\n    Main application class: wires UI, hotkeys, audio recorder, recognizer and clipboard.\r\n\r\n    MVP workflow:\r\n        global hotkey (record) down   -> start_recording()\r\n        global hotkey (record) up     -> stop_recording()\r\n        audio -> recognizer (Groq/GigaAM) -> postprocess -> clipboard.copy + paste\r\n    \"\"\"\r\n\r\n    def __init__(self) -> None:\r\n        self.qt_app = QApplication(sys.argv)\r\n\r\n        # Определяем базовую директорию приложения:\r\n        # - в dev-режиме: корень проекта (родитель src)\r\n        # - в собранном .exe: папка, где лежит exe\r\n        if getattr(sys, \"frozen\", False):\r\n            # PyInstaller / frozen\r\n            self.base_dir = Path(sys.executable).resolve().parent\r\n        else:\r\n            # Обычный запуск из исходников\r\n            self.base_dir = Path(__file__).resolve().parents[1]\r\n\r\n        # Load settings and logging (с учётом base_dir и config.local.yaml)\r\n        self.settings = self._load_or_init_settings()\r\n        setup_logging(self.settings.logging)\r\n\r\n        # Core components\r\n        self.window = FloatingWindow(self.settings.ui)\r\n        self.tray = SystemTrayIcon(self.window, self.settings.app)\r\n        self.clipboard = ClipboardManager()\r\n        self.audio_recorder = AudioRecorder(self.settings.audio)\r\n        self.recognizer = create_recognizer(self.settings.recognition)\r\n\r\n        # Постпроцессинг текста.\r\n        # ВАЖНО: сразу прокидываем в postprocess.* тот же ключ, model_process и base_url,\r\n        # что и в recognition.*, чтобы LLM работал уже при первом запуске.\r\n        post_cfg = self.settings.postprocess\r\n        rec_cfg = self.settings.recognition\r\n\r\n        if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n            # один ключ Groq: берём из recognition.groq.api_key\r\n            setattr(post_cfg.groq, \"api_key\", rec_cfg.groq.api_key)\r\n            # модель LLM: из recognition.groq.model_process\r\n            if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n                setattr(post_cfg.groq, \"model_process\", rec_cfg.groq.model_process)\r\n\r\n        if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n            # ключ для LLM всегда берём из поля OpenAI API key (recognition.openai.api_key)\r\n            setattr(post_cfg.openai, \"api_key\", rec_cfg.openai.api_key)\r\n            # модель LLM\r\n            if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n                setattr(post_cfg.openai, \"model_process\", rec_cfg.openai.model_process)\r\n            # базовый URL LLM = тот же, что и у ASR\r\n            setattr(post_cfg.openai, \"base_url\", rec_cfg.openai.base_url)\r\n\r\n        self.postprocessor = TextPostprocessor(post_cfg)\r\n\r\n        # Первое сообщение: если нет ключа для текущего backend'а — подсказка пользователю\r\n        backend = (self.settings.recognition.backend or \"groq\").lower()\r\n        missing_key = False\r\n        if backend == \"groq\" and not (self.settings.recognition.groq.api_key or \"\").strip():\r\n            missing_key = True\r\n        elif backend == \"openai\" and not (self.settings.recognition.openai.api_key or \"\").strip():\r\n            missing_key = True\r\n\r\n        if missing_key:\r\n            self.window.result_label.setText(\r\n                \"Добавьте API‑ключ в настройках (⚙️) перед использованием распознавания.\"\r\n            )\r\n\r\n        # State\r\n        self._is_recording: bool = False\r\n\r\n        # Hotkeys\r\n        self.hotkeys = HotKeyManager(\r\n            record_hotkey=self.settings.hotkeys.record,\r\n            cancel_hotkey=self.settings.hotkeys.cancel,\r\n            toggle_window_hotkey=self.settings.hotkeys.toggle_window,\r\n            toggle_debug_hotkey=self.settings.hotkeys.toggle_debug,\r\n            on_record_press=self.start_recording,\r\n            on_record_release=self.stop_recording,\r\n            on_cancel=self.cancel_recording,\r\n            on_toggle_window=self.toggle_window_visibility,\r\n            on_toggle_debug=self.toggle_debug_mode,\r\n        )\r\n\r\n        # Wire UI signals\r\n        self.window.settings_requested.connect(self.open_settings_dialog)\r\n        self.window.exit_requested.connect(self.quit)\r\n        self.tray.show_window_requested.connect(self.show_window)\r\n        self.tray.settings_requested.connect(self.open_settings_dialog)\r\n        self.tray.toggle_debug_requested.connect(self.toggle_debug_mode)\r\n        self.tray.exit_requested.connect(self.quit)\r\n\r\n    # --------------------------------------------------------------------- UI\r\n\r\n    def show_window(self) -> None:\r\n        self.window.show()\r\n        self.window.raise_()\r\n        self.window.activateWindow()\r\n\r\n    def toggle_window_visibility(self) -> None:\r\n        \"\"\"\r\n        Горячая клавиша \"Показать/скрыть окно\".\r\n\r\n        Для твоего сценария окно должно быть ВСЕГДА видно, поэтому\r\n        мы больше не будем его прятать, а только:\r\n        - если оно свернуто в компактный режим — разворачивать,\r\n        - если оно где-то \"потерялось\" — показывать и поднимать наверх.\r\n        \"\"\"\r\n        # просто гарантируем, что окно показано и на переднем плане\r\n        self.show_window()\r\n\r\n    def open_settings_dialog(self) -> None:\r\n        \"\"\"\r\n        Открыть диалог настроек (SettingsDialog) и применить изменения.\r\n        \"\"\"\r\n        from ui.settings_dialog import SettingsDialog  # локальный импорт, чтобы избежать циклов\r\n\r\n        # показать основное окно, чтобы диалог был поверх\r\n        self.show_window()\r\n\r\n        dlg = SettingsDialog(self.settings, parent=self.window)\r\n        if dlg.exec() != dlg.DialogCode.Accepted:\r\n            return\r\n\r\n        new_settings = dlg.get_result()\r\n        if new_settings is None:\r\n            return\r\n\r\n        # обновляем настройки в памяти\r\n        self.settings = new_settings\r\n\r\n        # сохраняем в config.yaml\r\n        AppSettings.save_default(self.settings)\r\n\r\n        # пересоздаём recognizer и postprocessor с учётом новых настроек\r\n        self.recognizer = create_recognizer(self.settings.recognition)\r\n\r\n        post_cfg = self.settings.postprocess\r\n        rec_cfg = self.settings.recognition\r\n\r\n        if (post_cfg.llm_backend or \"\").lower() == \"groq\":\r\n            setattr(post_cfg.groq, \"api_key\", rec_cfg.groq.api_key)\r\n            if not getattr(post_cfg.groq, \"model_process\", \"\"):\r\n                setattr(post_cfg.groq, \"model_process\", rec_cfg.groq.model_process)\r\n\r\n        if (post_cfg.llm_backend or \"\").lower() == \"openai\":\r\n            setattr(post_cfg.openai, \"api_key\", rec_cfg.openai.api_key)\r\n            if not getattr(post_cfg.openai, \"model_process\", \"\"):\r\n                setattr(post_cfg.openai, \"model_process\", rec_cfg.openai.model_process)\r\n            # базовый URL LLM = тот же, что и у ASR\r\n            setattr(post_cfg.openai, \"base_url\", rec_cfg.openai.base_url)\r\n\r\n        self.postprocessor = TextPostprocessor(post_cfg)\r\n\r\n        # если теперь ключи заданы — убрать предупреждающую надпись\r\n        backend = (self.settings.recognition.backend or \"groq\").lower()\r\n        has_key = False\r\n        if backend == \"groq\" and (self.settings.recognition.groq.api_key or \"\").strip():\r\n            has_key = True\r\n        elif backend == \"openai\" and (self.settings.recognition.openai.api_key or \"\").strip():\r\n            has_key = True\r\n\r\n        if has_key:\r\n            if hasattr(self.window, \"set_raw_text\"):\r\n                self.window.set_raw_text(\"\")\r\n            if hasattr(self.window, \"set_processed_text\"):\r\n                self.window.set_processed_text(\"\")\r\n            self.window.result_label.setText(\"\")\r\n\r\n        self.window.show_message(\"Настройки сохранены.\", timeout_ms=1500)\r\n\r\n    # ----------------------------------------------------------------- Hotkeys\r\n\r\n    def start_recording(self) -> None:\r\n        if self._is_recording:\r\n            return\r\n        self._is_recording = True\r\n        self.window.set_state(\"recording\")\r\n\r\n        def on_finished(audio_data):\r\n            # Этот колбэк вызывается из потока рекордера.\r\n            # Возвращаемся к синхронной обработке, как в рабочем варианте.\r\n            self._process_audio(audio_data)\r\n\r\n        self.audio_recorder.start(on_finished=on_finished)\r\n\r\n    def stop_recording(self) -> None:\r\n        if not self._is_recording:\r\n            return\r\n        self._is_recording = False\r\n        self.audio_recorder.stop()\r\n\r\n    def cancel_recording(self) -> None:\r\n        if not self._is_recording:\r\n            return\r\n        self._is_recording = False\r\n        self.audio_recorder.cancel()\r\n        self.window.set_state(\"idle\")\r\n\r\n    # ----------------------------------------------------------- Processing\r\n\r\n    def _process_audio(self, audio_data) -> None:\r\n        \"\"\"\r\n        Синхронная обработка аудио с каскадом backend'ов:\r\n        1) основной backend из настроек (groq / openai / local),\r\n        2) при ошибке — fallback на остальные по приоритету.\r\n        \"\"\"\r\n        from loguru import logger\r\n        from pathlib import Path\r\n        from datetime import datetime\r\n        from recognition.postprocessor import TextPostprocessor as TP  # для _simple_cleanup\r\n        from recognition import create_recognizer  # каскадное создание по backend'у\r\n\r\n        self.window.set_state(\"processing\")\r\n\r\n        # Собираем приоритетный список backend'ов:\r\n        # сначала выбранный пользователем, затем остальные.\r\n        primary = (self.settings.recognition.backend or \"groq\").lower()\r\n        all_backends = [\"groq\", \"openai\", \"local\"]\r\n        cascade = [b for b in [primary] + all_backends if b in all_backends]\r\n        # Убираем дубликаты, сохраняя порядок\r\n        seen = set()\r\n        ordered_backends = []\r\n        for b in cascade:\r\n            if b not in seen:\r\n                seen.add(b)\r\n                ordered_backends.append(b)\r\n\r\n        last_error: str | None = None\r\n        raw_text: str | None = None\r\n\r\n        for backend in ordered_backends:\r\n            try:\r\n                logger.info(\"Trying recognition backend: {}\", backend)\r\n                # Временно подменяем backend в настройках для фабрики\r\n                original_backend = self.settings.recognition.backend\r\n                self.settings.recognition.backend = backend\r\n                recognizer = create_recognizer(self.settings.recognition)\r\n                # ВАЖНО: возвращаем исходный backend в настройках\r\n                self.settings.recognition.backend = original_backend\r\n\r\n                raw_text = recognizer.transcribe(audio_data)\r\n                logger.info(\"Recognition succeeded with backend: {}\", backend)\r\n                break\r\n            except RuntimeError as exc:\r\n                # Осмысленная ошибка — логируем и пробуем следующий backend\r\n                logger.error(\"Recognition error on backend {}: {}\", backend, exc)\r\n                last_error = str(exc)\r\n                continue\r\n            except Exception as exc:  # noqa: BLE001\r\n                logger.exception(\"Unexpected recognition error on backend {}: {}\", backend, exc)\r\n                last_error = f\"Неизвестная ошибка backend '{backend}'. См. логи.\"\r\n                continue\r\n\r\n        if raw_text is None:\r\n            # Все backend'ы упали — показываем последнюю ошибку\r\n            msg = last_error or \"Не удалось распознать аудио ни одним backend'ом.\"\r\n            self.window.set_state(\"error\")\r\n            self.window.show_message(msg)\r\n            return\r\n\r\n        from loguru import logger as _logger\r\n\r\n        try:\r\n            # 2) regex-очистка (базовый препроцессинг всегда)\r\n            regex_text = TP._simple_cleanup(raw_text or \"\")\r\n\r\n            # 3) LLM-постпроцессинг (если включён в конфиге)\r\n            processed_text = regex_text\r\n            try:\r\n                processed_text = self.postprocessor.process(raw_text or \"\")\r\n            except RuntimeError as exc:\r\n                _logger.error(\"LLM postprocess error: {}\", exc)\r\n                self.window.show_message(str(exc))\r\n            except Exception as exc:  # noqa: BLE001\r\n                _logger.exception(\"Unexpected LLM postprocess error: {}\", exc)\r\n                self.window.show_message(\"Ошибка LLM-постпроцессинга. См. логи.\")\r\n\r\n            # 4) показать оба варианта в окне\r\n            try:\r\n                if hasattr(self.window, \"set_raw_text\"):\r\n                    self.window.set_raw_text(raw_text or \"\")\r\n                else:\r\n                    self.window.result_label.setText(processed_text or \"\")\r\n\r\n                if hasattr(self.window, \"set_processed_text\"):\r\n                    self.window.set_processed_text(processed_text or \"\")\r\n            except Exception:\r\n                _logger.debug(\"window text update failed\", exc_info=True)\r\n\r\n            # 5) положить ОБРАБОТАННЫЙ текст в буфер обмена\r\n            self.clipboard.copy(processed_text or \"\")\r\n\r\n            # 6) авто-вставка текста через Ctrl+V (с ретраями внутри ClipboardManager)\r\n            self.clipboard.paste()\r\n\r\n            # 7) сохранить распознавание в отдельный текстовый лог с ротацией по ~3 МБ\r\n            try:\r\n                base_dir = Path(__file__).resolve().parents[2]\r\n                log_dir = base_dir / \"logs\"\r\n                log_dir.mkdir(parents=True, exist_ok=True)\r\n                transcript_path = log_dir / \"transcripts.log\"\r\n\r\n                max_size_bytes = 3 * 1024 * 1024\r\n                if transcript_path.exists() and transcript_path.stat().st_size >= max_size_bytes:\r\n                    ts = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\r\n                    rotated = log_dir / f\"transcripts_{ts}.log\"\r\n                    transcript_path.rename(rotated)\r\n\r\n                with transcript_path.open(\"a\", encoding=\"utf-8\") as f:\r\n                    f.write(\r\n                        f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]\\\\n\"\r\n                        f\"RAW: { (raw_text or '').strip() }\\\\n\"\r\n                        f\"PROCESSED: { (processed_text or '').strip() }\\\\n\"\r\n                        \"----------------------------------------\\\\n\"\r\n                    )\r\n            except Exception as exc:  # noqa: BLE001\r\n                _logger.exception(\"Failed to append transcript log: {}\", exc)\r\n\r\n            self.window.set_state(\"ready\")\r\n        except Exception as exc:  # noqa: BLE001\r\n            _logger.exception(\"Unexpected error during post-processing: {}\", exc)\r\n            self.window.set_state(\"error\")\r\n            self.window.show_message(\"Неизвестная ошибка постобработки. См. логи.\")\r\n\r\n    # -------------------------------------------------------------- Debug\r\n\r\n    def toggle_debug_mode(self) -> None:\r\n        # Placeholder: will reconfigure logging level later\r\n        self.window.show_message(\"Toggle debug (not fully implemented yet).\")\r\n\r\n    # ----------------------------------------------------------- Settings / config helpers\r\n\r\n    def _load_or_init_settings(self) -> AppSettings:\r\n        \"\"\"\r\n        Загрузка настроек с учётом портативного режима.\r\n\r\n        Логика:\r\n        - Ищем config.yaml в self.base_dir (рядом с exe или в корне проекта).\r\n        - Если файла нет — создаём минимальный config.yaml с backend=local.\r\n        - Затем вызываем AppSettings.load_default(), который уже умеет\r\n          подмешивать config.local.yaml поверх config.yaml.\r\n        \"\"\"\r\n        config_path = self.base_dir / \"config.yaml\"\r\n\r\n        if not config_path.exists():\r\n            # Минимальный конфиг по умолчанию: локальный backend, безопасные значения.\r\n            default_config = {\r\n                \"app\": {\r\n                    \"name\": \"VoiceCapture\",\r\n                    \"version\": \"0.1.0\",\r\n                },\r\n                \"hotkeys\": {\r\n                    \"record\": \"ctrl+win\",\r\n                    \"cancel\": \"esc\",\r\n                    \"toggle_window\": \"ctrl+alt+s\",\r\n                    \"toggle_debug\": \"ctrl+alt+d\",\r\n                },\r\n                \"audio\": {\r\n                    \"sample_rate\": 16000,\r\n                    \"channels\": 1,\r\n                    \"max_duration\": 120,\r\n                },\r\n                \"recognition\": {\r\n                    \"backend\": \"local\",\r\n                    \"local\": {\r\n                        \"model\": \"large-v3\",\r\n                        \"device\": \"cuda\",\r\n                        \"compute_type\": \"float16\",\r\n                        \"language\": \"ru\",\r\n                        \"beam_size\": 5,\r\n                        \"temperature\": 0.0,\r\n                        \"hf_token\": \"\",\r\n                    },\r\n                    \"openai\": {\r\n                        \"api_key\": \"\",\r\n                        \"model\": \"whisper-1\",\r\n                        \"model_process\": \"gpt-4o-mini\",\r\n                        \"language\": \"ru\",\r\n                        # base_url намеренно оставляем пустым, чтобы пользователь\r\n                        # задал его в настройках (OpenAI Base URL).\r\n                        \"base_url\": \"\",\r\n                    },\r\n                    \"groq\": {\r\n                        \"api_key\": \"\",\r\n                        \"model\": \"whisper-large-v3\",\r\n                        \"model_process\": \"llama-3.3-70b-versatile\",\r\n                        \"language\": \"ru\",\r\n                    },\r\n                },\r\n                # Блок postprocess больше не хранит ключи / base_url.\r\n                # Здесь только включение, режим и \"отображательные\" модели.\r\n                \"postprocess\": {\r\n                    \"enabled\": True,\r\n                    \"mode\": \"llm\",\r\n                    \"llm_backend\": \"groq\",\r\n                    \"groq\": {\r\n                        \"model\": \"llama-3.3-70b-versatile\",\r\n                    },\r\n                    \"openai\": {\r\n                        \"model\": \"gpt-5.1\",\r\n                    },\r\n                },\r\n                \"ui\": {\r\n                    # Старые поля width/height/compact_mode больше не используются,\r\n                    # но при первой генерации конфига запишем их для обратной совместимости.\r\n                    \"width\": 320,\r\n                    \"height\": 200,\r\n                    \"opacity\": 0.9,\r\n                    \"compact_mode\": False,\r\n                },\r\n                \"logging\": {\r\n                    \"level\": \"INFO\",\r\n                    \"log_dir\": \"logs\",\r\n                },\r\n            }\r\n\r\n            try:\r\n                import yaml\r\n\r\n                with config_path.open(\"w\", encoding=\"utf-8\") as f:\r\n                    yaml.safe_dump(default_config, f, allow_unicode=True, sort_keys=False)\r\n            except Exception:\r\n                # Если по какой-то причине не удалось записать файл — продолжаем\r\n                # с дефолтами из dataclass'ов AppSettings.\r\n                pass\r\n\r\n        # Теперь загружаем настройки стандартным способом:\r\n        settings = AppSettings.load_default()\r\n\r\n        # Гарантируем, что backend задан\r\n        if not getattr(settings.recognition, \"backend\", None):\r\n            settings.recognition.backend = \"local\"\r\n\r\n        return settings\r\n\r\n    # -------------------------------------------------------------- Lifecycle\r\n\r\n    def quit(self) -> None:\r\n        self.hotkeys.stop()\r\n        self.qt_app.quit()\r\n\r\n    def run(self) -> None:\r\n        self.hotkeys.start()\r\n        self.show_window()\r\n        sys.exit(self.qt_app.exec())\r\n\r\n\r\ndef main() -> None:\r\n    app = App()\r\n    app.run()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()"
        }
    ]
}