{
    "sourceFile": "src/hotkey/hotkey_manager.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1764289577076,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764291688981,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,12 +113,13 @@\n             self.callbacks.on_toggle_debug,\r\n             suppress=False,\r\n         )\r\n \r\n-        # Block until stop() is called; keyboard.wait() waits for 'esc' by default,\r\n-        # so we emulate a simple loop.\r\n+        # Block until stop() is called; simple polling loop.\r\n+        import time\r\n+\r\n         while self._running:\r\n-            keyboard.sleep(0.1)\r\n+            time.sleep(0.1)\r\n \r\n     @staticmethod\r\n     def _normalize_hotkey_main_key(hotkey: str) -> str:\r\n         \"\"\"\r\n"
                },
                {
                    "date": 1764293057269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,19 +85,24 @@\n         \"\"\"\r\n         Register hotkeys and block in a loop until stop() is called.\r\n         \"\"\"\r\n         # Record press / release\r\n-        keyboard.on_press_key(\r\n-            self._normalize_hotkey_main_key(self.record_hotkey),\r\n-            lambda e: self.callbacks.on_record_press(),\r\n-            suppress=False,\r\n-        )\r\n-        keyboard.on_release_key(\r\n-            self._normalize_hotkey_main_key(self.record_hotkey),\r\n-            lambda e: self.callbacks.on_record_release(),\r\n-            suppress=False,\r\n-        )\r\n+        main_key = self._normalize_hotkey_main_key(self.record_hotkey)\r\n \r\n+        # ВАЖНО: не трогаем сам Ctrl, чтобы не ломать двойной Ctrl у других программ.\r\n+        # Слушаем только основной \"буквенный\" ключ (например, Win или S и т.п.).\r\n+        if main_key.lower() not in {\"ctrl\", \"control\"}:\r\n+            keyboard.on_press_key(\r\n+                main_key,\r\n+                lambda e: self.callbacks.on_record_press(),\r\n+                suppress=False,\r\n+            )\r\n+            keyboard.on_release_key(\r\n+                main_key,\r\n+                lambda e: self.callbacks.on_record_release(),\r\n+                suppress=False,\r\n+            )\r\n+\r\n         # Cancel\r\n         keyboard.add_hotkey(self.cancel_hotkey, self.callbacks.on_cancel, suppress=False)\r\n \r\n         # Toggle window\r\n"
                },
                {
                    "date": 1764293196290,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,24 +85,23 @@\n         \"\"\"\r\n         Register hotkeys and block in a loop until stop() is called.\r\n         \"\"\"\r\n         # Record press / release\r\n-        main_key = self._normalize_hotkey_main_key(self.record_hotkey)\r\n+        # Вместо низкоуровневого перехвата Ctrl/Win используем add_hotkey\r\n+        # для всей комбинации, чтобы не ломать другие обработчики Ctrl.\r\n+        keyboard.add_hotkey(\r\n+            self.record_hotkey,\r\n+            self.callbacks.on_record_press,\r\n+            suppress=False,\r\n+            trigger_on_release=False,\r\n+        )\r\n+        keyboard.add_hotkey(\r\n+            self.record_hotkey,\r\n+            self.callbacks.on_record_release,\r\n+            suppress=False,\r\n+            trigger_on_release=True,\r\n+        )\r\n \r\n-        # ВАЖНО: не трогаем сам Ctrl, чтобы не ломать двойной Ctrl у других программ.\r\n-        # Слушаем только основной \"буквенный\" ключ (например, Win или S и т.п.).\r\n-        if main_key.lower() not in {\"ctrl\", \"control\"}:\r\n-            keyboard.on_press_key(\r\n-                main_key,\r\n-                lambda e: self.callbacks.on_record_press(),\r\n-                suppress=False,\r\n-            )\r\n-            keyboard.on_release_key(\r\n-                main_key,\r\n-                lambda e: self.callbacks.on_record_release(),\r\n-                suppress=False,\r\n-            )\r\n-\r\n         # Cancel\r\n         keyboard.add_hotkey(self.cancel_hotkey, self.callbacks.on_cancel, suppress=False)\r\n \r\n         # Toggle window\r\n"
                },
                {
                    "date": 1764293295072,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,22 +85,15 @@\n         \"\"\"\r\n         Register hotkeys and block in a loop until stop() is called.\r\n         \"\"\"\r\n         # Record press / release\r\n-        # Вместо низкоуровневого перехвата Ctrl/Win используем add_hotkey\r\n-        # для всей комбинации, чтобы не ломать другие обработчики Ctrl.\r\n+        # Возвращаемся к простой схеме: один хоткей = \"нажали → если не пишем, начать запись,\r\n+        # если уже пишем, остановить\". Это убирает залипание состояний.\r\n         keyboard.add_hotkey(\r\n             self.record_hotkey,\r\n-            self.callbacks.on_record_press,\r\n+            self._toggle_record,\r\n             suppress=False,\r\n-            trigger_on_release=False,\r\n         )\r\n-        keyboard.add_hotkey(\r\n-            self.record_hotkey,\r\n-            self.callbacks.on_record_release,\r\n-            suppress=False,\r\n-            trigger_on_release=True,\r\n-        )\r\n \r\n         # Cancel\r\n         keyboard.add_hotkey(self.cancel_hotkey, self.callbacks.on_cancel, suppress=False)\r\n \r\n@@ -126,10 +119,29 @@\n \r\n     @staticmethod\r\n     def _normalize_hotkey_main_key(hotkey: str) -> str:\r\n         \"\"\"\r\n-        Extract main key from a hotkey string like 'ctrl+win' or 'ctrl+alt+s'.\r\n+        Оставлено для совместимости, сейчас не используется.\r\n+        \"\"\"\r\n+        parts = hotkey.split(\"+\")\r\n+        return parts[-1].strip()\r\n \r\n\\ No newline at end of file\n-        For MVP we assume the last part is the main key.\r\n+    # ----------------------------------------------------------------- helpers\r\n+\r\n+    def _toggle_record(self) -> None:\r\n         \"\"\"\r\n-        parts = hotkey.split(\"+\")\r\n-        return parts[-1].strip()\n+        Один хоткей переключает запись:\r\n+        - если сейчас не пишем → on_record_press()\r\n+        - если уже пишем      → on_record_release()\r\n+        \"\"\"\r\n+        # Простейшая логика: App сам хранит флаг is_recording,\r\n+        # поэтому мы просто вызываем оба колбэка по очереди,\r\n+        # а App решает, что делать.\r\n+        # Если нужно, можно заменить на явный флаг в HotKeyManager.\r\n+        try:\r\n+            self.callbacks.on_record_press()\r\n+        except Exception:\r\n+            pass\r\n+        try:\r\n+            self.callbacks.on_record_release()\r\n+        except Exception:\r\n+            pass\n\\ No newline at end of file\n"
                },
                {
                    "date": 1764293375269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,15 +85,22 @@\n         \"\"\"\r\n         Register hotkeys and block in a loop until stop() is called.\r\n         \"\"\"\r\n         # Record press / release\r\n-        # Возвращаемся к простой схеме: один хоткей = \"нажали → если не пишем, начать запись,\r\n-        # если уже пишем, остановить\". Это убирает залипание состояний.\r\n-        keyboard.add_hotkey(\r\n-            self.record_hotkey,\r\n-            self._toggle_record,\r\n+        # Явно разделяем старт и стоп по нажатию/отжатию основной клавиши,\r\n+        # чтобы не было залипания.\r\n+        main_key = self._normalize_hotkey_main_key(self.record_hotkey)\r\n+\r\n+        keyboard.on_press_key(\r\n+            main_key,\r\n+            lambda e: self.callbacks.on_record_press(),\r\n             suppress=False,\r\n         )\r\n+        keyboard.on_release_key(\r\n+            main_key,\r\n+            lambda e: self.callbacks.on_record_release(),\r\n+            suppress=False,\r\n+        )\r\n \r\n         # Cancel\r\n         keyboard.add_hotkey(self.cancel_hotkey, self.callbacks.on_cancel, suppress=False)\r\n \r\n"
                }
            ],
            "date": 1764289577076,
            "name": "Commit-0",
            "content": "from __future__ import annotations\r\n\r\nfrom dataclasses import dataclass\r\nfrom threading import Thread\r\nfrom typing import Callable, Optional\r\n\r\nimport keyboard  # type: ignore[import]\r\n\r\n\r\nCallback = Callable[[], None]\r\n\r\n\r\n@dataclass\r\nclass HotkeyCallbacks:\r\n    on_record_press: Callback\r\n    on_record_release: Callback\r\n    on_cancel: Callback\r\n    on_toggle_window: Callback\r\n    on_toggle_debug: Callback\r\n\r\n\r\nclass HotKeyManager:\r\n    \"\"\"\r\n    Global hotkey manager using `keyboard` library.\r\n\r\n    Default bindings (configurable via config.yaml):\r\n        - record:        ctrl+win   (press / release)\r\n        - cancel:        esc\r\n        - toggle_window: ctrl+alt+s\r\n        - toggle_debug:  ctrl+alt+d\r\n    \"\"\"\r\n\r\n    def __init__(\r\n        self,\r\n        record_hotkey: str,\r\n        cancel_hotkey: str,\r\n        toggle_window_hotkey: str,\r\n        toggle_debug_hotkey: str,\r\n        on_record_press: Callback,\r\n        on_record_release: Callback,\r\n        on_cancel: Callback,\r\n        on_toggle_window: Callback,\r\n        on_toggle_debug: Callback,\r\n    ) -> None:\r\n        self.record_hotkey = record_hotkey\r\n        self.cancel_hotkey = cancel_hotkey\r\n        self.toggle_window_hotkey = toggle_window_hotkey\r\n        self.toggle_debug_hotkey = toggle_debug_hotkey\r\n\r\n        self.callbacks = HotkeyCallbacks(\r\n            on_record_press=on_record_press,\r\n            on_record_release=on_record_release,\r\n            on_cancel=on_cancel,\r\n            on_toggle_window=on_toggle_window,\r\n            on_toggle_debug=on_toggle_debug,\r\n        )\r\n\r\n        self._listener_thread: Optional[Thread] = None\r\n        self._running: bool = False\r\n\r\n    # ------------------------------------------------------------------ public\r\n\r\n    def start(self) -> None:\r\n        \"\"\"\r\n        Start listening for global hotkeys in a background thread.\r\n        \"\"\"\r\n        if self._running:\r\n            return\r\n        self._running = True\r\n        self._listener_thread = Thread(target=self._listen_loop, daemon=True)\r\n        self._listener_thread.start()\r\n\r\n    def stop(self) -> None:\r\n        \"\"\"\r\n        Stop listening for hotkeys.\r\n        \"\"\"\r\n        if not self._running:\r\n            return\r\n        self._running = False\r\n        keyboard.unhook_all()\r\n\r\n    # ---------------------------------------------------------------- internal\r\n\r\n    def _listen_loop(self) -> None:\r\n        \"\"\"\r\n        Register hotkeys and block in a loop until stop() is called.\r\n        \"\"\"\r\n        # Record press / release\r\n        keyboard.on_press_key(\r\n            self._normalize_hotkey_main_key(self.record_hotkey),\r\n            lambda e: self.callbacks.on_record_press(),\r\n            suppress=False,\r\n        )\r\n        keyboard.on_release_key(\r\n            self._normalize_hotkey_main_key(self.record_hotkey),\r\n            lambda e: self.callbacks.on_record_release(),\r\n            suppress=False,\r\n        )\r\n\r\n        # Cancel\r\n        keyboard.add_hotkey(self.cancel_hotkey, self.callbacks.on_cancel, suppress=False)\r\n\r\n        # Toggle window\r\n        keyboard.add_hotkey(\r\n            self.toggle_window_hotkey,\r\n            self.callbacks.on_toggle_window,\r\n            suppress=False,\r\n        )\r\n\r\n        # Toggle debug\r\n        keyboard.add_hotkey(\r\n            self.toggle_debug_hotkey,\r\n            self.callbacks.on_toggle_debug,\r\n            suppress=False,\r\n        )\r\n\r\n        # Block until stop() is called; keyboard.wait() waits for 'esc' by default,\r\n        # so we emulate a simple loop.\r\n        while self._running:\r\n            keyboard.sleep(0.1)\r\n\r\n    @staticmethod\r\n    def _normalize_hotkey_main_key(hotkey: str) -> str:\r\n        \"\"\"\r\n        Extract main key from a hotkey string like 'ctrl+win' or 'ctrl+alt+s'.\r\n\r\n        For MVP we assume the last part is the main key.\r\n        \"\"\"\r\n        parts = hotkey.split(\"+\")\r\n        return parts[-1].strip()"
        }
    ]
}